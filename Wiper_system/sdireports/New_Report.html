<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <style>
        /* Copyright 2021 The MathWorks, Inc. */
        /* ----------- Global settings ----------- */

        :root {
            --whiteGray: rgba(250, 250, 250, 1);
            --lightestGray: rgba(248, 248, 248, 1);
            --lighterGray: rgba(242, 242, 242, 1);
            --lightGray: rgba(218, 218, 218, 1);
            --mediumGray: rgba(153, 153, 153, 1);
            --headerColor: #696969;
            --darkGray: rgba(175, 175, 175, 1);
            --darkerGray: rgba(102, 102, 102, 1);
            --darkestGray: rgba(66, 66, 66, 1);
            --diffColor: rgba(250, 230, 213, 1);
            --resultGreen: rgba(0, 176, 91, 1);
            --resultRed: rgba(255, 0, 0, 1);
            --resultOrange: rgba(255, 115, 0, 1);
            --resultBlue: rgba(18, 86, 135, 1);
        }

        body {
            -webkit-print-color-adjust: exact;
            color-adjust: exact;
        }

        ::-webkit-scrollbar {
            width: 5px;
            padding-right: 35px;
        }

        ::-webkit-scrollbar-track {
            background: var(--lightestGray);
            border: 1px solid var(--lighterGray);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--lightGray);
            border-radius: 10px;
            visibility: visible;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--darkestGray);
            visibility: visible;
        }

        .unselectable {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* ----------- Container styles ----------- */

        /* ----- Base ----- */

        body,
        html {
            margin: 0;
            padding: 0;
        }

        /* ----- Header ----- */

        .header {
            border-style: solid;
            border-color: var(--darkGray);
            border-width: 1px 1px 2px 1px;
            background-color: var(--lighterGray);

            height: 50px;
            display: flex;
        }

        /* ----- Header-left ----- */

        .header-left {
            flex: 2;

            display: grid;

            grid-template-areas:
                "report-title report-title report-title report-title"
                "report-author report-version report-date report-space";

            grid-template-columns: auto auto auto 3fr;
            grid-template-rows: 30px 17px;
        }

        .report-title {
            font: bold 20px arial;
            padding-left: 5px;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;

            grid-area: report-title;
        }

        .report-author {
            font: normal 14px/17px arial;
            padding-left: 10px;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;

            grid-area: report-author;
        }

        .report-version {
            font: normal 14px/17px arial;
            padding-left: 15px;

            grid-area: report-version;
        }

        .report-date {
            font: normal 14px/17px arial;
            padding-left: 15px;
            text-overflow: ellipsis;
            white-space: nowrap;
            overflow: hidden;

            grid-area: report-date;
        }

        .report-space {
            font: normal 14px arial;

            grid-area: report-space;
        }

        /* ----- Header-right ----- */

        .header-right {
            flex: 1;

            display: flex;
            min-width: 175px;
        }

        .report-style {
            font: normal 14px arial;
            flex: 1;

            padding-right: 10px;
            text-align: right;
            align-self: center;
        }

        /* ----- Top level interactive ----- */

        .interactive {
            height: calc(100vh - 53px);
            border-left: 1px solid var(--darkGray);
            border-right: 1px solid var(--darkGray);
            border-bottom: 1px solid var(--darkGray);
            background-color: var(--lightestGray);
            box-sizing: border-box;

            display: grid;

            grid-template-areas:
                "signals vertical-sep visuals"
                "horizontal-sep vertical-sep visuals"
                "properties vertical-sep visuals";

            grid-template-columns: 350px 2px auto;
            grid-template-rows: 1fr 2px 1fr;
        }

        /* ----- Top level printable ----- */

        .printable {
            height: calc(100vh - 53px);
            background-color: white;
            box-sizing: border-box;

            display: none;

            grid-template-areas:
                "summary"
                "results";

            grid-template-columns: 1fr;
        }

        /* ----- Signal-Property Combination ----- */

        .summary {
            break-after: page;
            grid-area: summary;

            display: grid;

            grid-template-areas:
                "summary-label"
                "summary-data";
        }

        .summary-label {
            font: bold 16px arial;
            padding: 5px 0px 3px 5px;
            background-color: white;

            grid-area: summary-label;
        }

        .summary-data {
            padding: 2px 0px 0px 5px;
            background-color: white;

            grid-area: summary-data;
        }

        .results {
            break-before: page;
            grid-area: results;
            height: auto;
            width: auto;
        }

        .results-row {
            break-inside: avoid;
            break-before: page;
            padding: 2px 0px 0px 0px;
            background-color: white;

            grid-area: results-row;

            height: auto;
            width: auto;

            display: flex;
            flex-direction: column;
        }

        .results-label {
            font: bold 16px arial;
            padding: 5px 0px 5px 5px;

            grid-area: results-label;
        }

        .signals-n-properties {
            padding-left: 10px;
            min-height: 100px;
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-color: var(--mediumGray) transparent;
            scrollbar-width: thin;

            grid-area: signals-n-properties;
        }

        .print-visuals {
            padding-left: 5px;
            background-color: var(--whiteGray);

            grid-area: print-visuals;
        }

        #print-cmpr-plot {
            border: 1px solid var(--darkGray);
            width: 100%;
            height: 100%;
            max-height: 500px;
            object-fit: scale-down;
        }

        .print-sig-header {
            padding: 2px 0px 0px 5px;
            background-color: white;

            grid-area: print-sig-header;
        }

        .print-sig-data {
            break-after: page;
            padding-left: 5px;

            grid-area: print-sig-data;
        }

        .sig-prop-header {
            background-color: white;

            grid-area: sig-prop-header;
        }

        .sig-prop-data {
            padding-left: 0px;

            grid-area: sig-prop-data;
        }

        /* ----- Signals ----- */

        .signals {
            background-color: var(--lightestGray);

            grid-area: signals;
            display: grid;

            grid-template-areas:
                "sig-header sig-scroll"
                "sig-data sig-scroll";

            grid-template-columns: 1fr 5px;
            grid-template-rows: 18px 1fr;
        }

        .sig-header {
            padding: 0px 0px 0px 5px;
            border-bottom: 1px solid var(--darkGray);
            background-color: var(--lightestGray);

            grid-area: sig-header;
        }

        .sig-data {
            padding-left: 5px;
            min-height: 100px;
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-color: var(--mediumGray) transparent;
            scrollbar-width: thin;

            grid-area: sig-data;
        }

        .sig-scroll {
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-size: 6px;
            border-left: 1px solid var(--darkGray);

            grid-area: sig-scroll;
            display: none;
        }

        /* ----- Properties ----- */

        .properties {
            background-color: var(--lightestGray);
            border-bottom: 1px solid var(--darkGray);

            display: grid;

            grid-template-areas:
                "prop-title prop-title"
                "prop-header prop-scroll"
                "prop-data prop-scroll";

            grid-template-columns: 1fr 5px;
            grid-template-rows: 20px 18px 1fr;

            grid-area: properties;
        }

        .prop-title {
            padding: 0px 0px 0px 5px;
            font: normal 13px/20px arial;
            border-bottom: 1px solid var(--darkGray);

            grid-area: prop-title;
        }

        .prop-header {
            padding: 2px 0px 0px 5px;
            border-bottom: 1px solid var(--darkGray);
            background-color: var(--lightestGray);

            grid-area: prop-header;
        }

        .prop-data {
            padding-left: 5px;
            max-height: calc(100% -39px);
            min-height: 100px;
            overflow-x: hidden;
            overflow-y: auto;
            scrollbar-color: var(--mediumGray) var(--lightestGray);
            scrollbar-width: thin;

            grid-area: prop-data;
        }

        .prop-scroll {
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-size: 6px;
            border-left: 1px solid var(--darkGray);

            grid-area: prop-scroll;
            display: none;
        }

        /* ----- Column Resizing styles ----- */

        .cmpr-tbl-hdr-content {
            padding: 2px 0px 0px 5px;
            border-bottom: 1px solid var(--darkGray);
            background-color: var(--lightestGray);
        }

        .prop-hdr-col, .cmpr-hdr-col, .cmpr-cell-bdy .prop-resize-col {
            padding: 15px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* to show all different status icons in last column, the middle columns width is reduced a little */
        .cmpr-grid {
            display:grid;
            grid-template-columns:
                minmax(30px, 1.1fr)
                minmax(30px, 0.8fr)
                minmax(30px, 0.8fr)
                minmax(30px, 0.8fr)
                minmax(30px, 1.1fr);
        }

        .prop-grid {
            display:grid;
            grid-template-columns:
                minmax(30px, 1fr)
                minmax(30px, 1.166fr)
                minmax(30px, 1.166fr);
        }

        .prop-hdr-col, .cmpr-hdr-col {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            text-align: left;
            position: relative;
        }

        .prop-resize-handle, .cmpr-resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 3px;
            cursor: col-resize;
        }

        /* ----- Visuals ----- */

        .visuals {
            background-color: var(--whiteGray);
            border-bottom: 1px solid var(--darkGray);
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            grid-area: visuals;
            row-gap: 100px;
        }

        #cmpr-plot {
            max-width: 100%;
            max-height: 100%;

            min-width: 300px;
            min-height: 200px;

            width: fit-content;
            height: fit-content;

            object-fit: contain;
        }

        /* ----- Separators ----- */

        .horizontal-sep {
            background-color: var(--darkGray);
            cursor: ns-resize;

            grid-area: horizontal-sep;
        }

        .horizontal-sep:hover {
            background-color: var(--darkerGray);
        }

        .vertical-sep {
            background-color: var(--darkGray);
            cursor: ew-resize;

            grid-area: vertical-sep;
        }

        .vertical-sep:hover {
            background-color: var(--darkerGray);
        }

        /* ----- Printable table styles ----- */

        .print-summary-hdr:not(:last-child) {
            border-right: solid 1px var(--darkGray);
        }

        .print-summary-hdr:last-child {
            border-right: solid 1px var(--darkGray);
        }

        .print-summary-hdr:first-child {
            border-left: solid 1px var(--darkGray);
        }

        .print-summary-hdr {
            border-top: 1px solid var(--darkGray);
            color: var(--headerColor);
            font: normal 10px arial;
            text-transform: uppercase;
        }

        .print-summary-bdy {
            border-left: 1px solid var(--darkGray);
        }

        .print-summary-bdy:last-child {
            border-right: solid 1px var(--darkGray);
        }

        .print-summary-bdy,
        .print-summary-hdr {
            width: 20%;
        }

        .resultTable{
            border-collapse: collapse;
            border: 1px solid rgb(218, 218, 218);
            padding: 10px 10px;
            width: 80%;
            table-layout: fixed;
            padding: 1% 2%;
            cursor: text !important;
            user-select: text;
        }

        .resultTableHeading {
            background-color: #f8f8f8;
            height: 16px;
        }

        .headingSpan {
            float: left;
            vertical-align: bottom;
            margin-top:3px;
            margin-left: 2px;
            margin-right: 5px;
            font-size: 100%;
            font-weight: normal;
        }

        .resultStatus {
            font-size: 15px;
            font-family: Arial, Helvetica, sans-serif;
            user-select: text;
            cursor: text !important;
            font-style: normal;
            color: rgb(0, 0, 0);
            font-weight: 400;
        }

        /* ----- Common table styles ----- */

        .no-signals {
            font: italic bold 14px/17px arial;
            padding: 5px 0px 5px 10px;
        }

        .cmpr-tbl-common,
        .prop-tbl-common {
            border-collapse: collapse;
            width: 100%;
        }

        .prop-tbl-common.prop-data-tbl {
            table-layout: fixed;
        }

        .print-summary-common {
            border-collapse: collapse;
            width: 100%;
        }

        .header-data {
            border-top: solid 1px var(--darkGray);
            border-bottom: solid 1px var(--darkGray);
        }

        .bdy-data {
            border-bottom: solid 1px var(--darkGray);
        }

        .formFilt {
            align-self: right;
        }

        .cmpr-tbl-bdy-content {
            border-bottom: solid 1px var(--lightGray);
        }

        .cmpr-status-common {
            height: 14px;
            width: 14px;
            color: white;
            border-radius: 50%;
            display: inline-block;
            text-align: center;
            font: normal 11px/16px arial;
        }

        .cmpr-status-withinTolerance {
            font: normal 11px/16px arial;
            background-color: var(--resultGreen);
        }

        .cmpr-status-signalFailed {
            font: normal 11px/14px arial;
            background-color: var(--resultRed);
        }

        .cmpr-status-signalCanceled {
            font: normal 11px/14px arial;
            background-color: var(--resultBlue);
        }

        .cmpr-status-notAligned {
            font: bold 12px/12px arial;
            background-color: var(--resultOrange);
        }

        .common-cell-border:not(:last-child) {
            border-right: solid 1px var(--lightGray);
        }
        .common-cell-border-bottom {
            border-bottom: solid 1px var(--lightGray);
        }

        .common-cell {
            padding: 3px;
            text-align: left;
            white-space: nowrap;
        }

        .signal-cell {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cmpr-cell-hdr,
        .prop-cell-hdr-hrz,
        .prop-cell-hdr-blnk {
            color: var(--headerColor);
            font: normal 10px arial;
            text-transform: uppercase;
        }

        .prop-cell-hdr-hrz {
            padding: 3px;
            text-align: left;
        }

        .prop-cell-hdr-blnk {
            padding: 3px;
        }

        .sig-prop-cell-hdr-hrz,
        .sig-prop-cell-hdr-blnk {
            color: var(--headerColor);
            font: normal 10px arial;
            text-transform: uppercase;
            border-right: solid 1px var(--lightGray);
            border-left: solid 1px var(--lightGray);
        }

        .sig-prop-cell-hdr-hrz {
            padding: 3px;
            width: 35%;
            text-align: left;
        }

        .sig-prop-cell-hdr-blnk {
            padding: 3px;
            width: 30%;
        }

        .cmpr-row,
        .prop-row {
            font: normal 12px arial;
        }

        .cmpr-row-selected {
            color: white;
            font: normal 12px arial;
            background-color: var(--darkerGray);
        }

        .prop-cell {
            font: normal 12px arial;
            color: var(--darkerGray);
            background-color: var(--whiteGray);
        }

        .prop-cell-diff {
            font: normal 12px arial;
            color: var(--darkerGray);
            background-color: var(--diffColor);
        }

        .prop-cell-hdr-vrt {
            font: normal 12px arial;
            color: var(--darkestGray);
            background-color: var(--whiteGray);
        }

        .prop-cell-hdr-vrt-diff {
            font: bold 12px arial;
            color: var(--darkestGray);
            background-color: var(--whiteGray);
        }

        .sig-prop-cell {
            font: normal 12px arial;
            color: var(--darkerGray);
            width: 35%;
            background-color: white;
            border-right: solid 1px var(--lightGray);
        }

        .sig-prop-cell-diff {
            font: normal 12px arial;
            color: var(--darkerGray);
            width: 35%;
            background-color: var(--diffColor);
            border-right: solid 1px var(--lightGray);
        }

        .sig-prop-cell-hdr-vrt {
            font: normal 12px arial;
            color: var(--darkestGray);
            width: 30%;
            background-color: white;
            border-left: solid 1px var(--lightGray);
        }

        .sig-prop-cell-hdr-vrt-diff {
            font: bold 12px arial;
            color: var(--darkestGray);
            background-color: white;
            border-left: solid 1px var(--lightGray);
        }

        .line-base,
        .line-cmpr {
            width: 100px;
            border: 3px solid var(--lightestGray);
        }

        @media print {
            .report-style {
                display: none;
            }

            .interactive {
                display: none !important;
            }

            .printable {
                display: grid !important;
            }

            .print-blank {
                break-after: page;
            }

            .print-visuals {
                background-color: var(--lightestGray) !important;
                padding-left: 0px !important;
            }

            .signals-n-properties {
                padding-bottom: 25px !important;
            }

            .results-row {
                display: flex !important;
                flex-direction: column !important;
                padding-bottom: 5px;
            }

            #print-cmpr-plot {
                display: block !important;
                margin-left: auto !important;
                margin-right: auto !important;
                max-height: 650px !important;
            }
        }



    </style>

    <title></title>
<style>
/* Copyright 2021 The MathWorks, Inc. */
/* ----- Signals Table Sorting Columns -----*/

.arrow-up {
    top: 4px;
    bottom: auto;
    border-bottom: 4px solid black;
    display: none;
}

th.cmpr-cell-hdr:hover .arrow-up,
th.cmpr-cell-hdr:hover .arrow-down {
    display: block;
}

.arrow:hover {
    opacity: 0.7;
}

.arrow-down {
    display: none;
    top: auto;
    bottom: 4px;
    border-top: 4px solid black;
}

.arrow {
    position: absolute;
    right: 5px;
    transition: opacity 0.5s ease;
    opacity: 0.3;
    cursor: pointer;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
}

.sort-des {
    top: 6px;
    bottom: auto;
    border-bottom: 6px solid black;
}

.sort-asc {
    top: auto;
    bottom: 6px;
    border-top: 6px solid black;
}

.cmpr-cell-hdr {
    cursor: pointer;
}

.cmprHeaderContent {
    margin-right: 10px;
    overflow-x: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    width: inherit;
}

.group-right-arrow {
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-left: 5px solid black;
    display: inline-block;
    padding-right: 6px;
}

.group-down-arrow {
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 5px solid black;
    display: inline-block;
    margin-right: 5px;
}

.group-button {
    border: none;
    background: none;
}

.row-display-off {
    display:none;
}

button:focus {
    outline: none;
}

.groupIcon {
    padding-right: 5px;
    display:inline;
}

.group {
    display:flex;
    flex-direction: row;
    justify-content: flex-start;
    align-items: center;
}

.groupCell {
    display: flex;
}

</style>
</head>


<body>
    <script type="text/javascript">
        function getImage(imageSelect) {
            let imageData1 = 'data:image/png;base64,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cXF4enri6el5zucNDAyg1+txd3e/6HnscDjYt28fb731FgkJCfz4xz8mPT2drVu3kp+fD5w5D6xW66h6dtWt0+nEZDIRExPD448/ft6pZmPh5eWFxWIZdS2aTCYlGej5jptrHy7W6TUajVitVqWurFYrDodDGSF2oTKv9n0tMzOTO++8k1deeQWtVstdd91FcHDwebf99H34SpjNZk6ePElUVNRl/84MDw/zySefKEuRl5WVKe+5ublRWlpKa2urstKOyWQaVQcmk0kZRei6J3z63HHVgVarZc2aNaxZs4by8nJee+011q9fT319Pd/5znfG9FDgcmg0Gtzc3JR9gDPXgCufj5eXlzKi4+zr++zzzBV8vO+++5g+ffo57Qa9Xn9F+3b2cblR8n8AeHp6YrPZRl1HFouFrq6uUYEi+Pe9cMGCBdxzzz1KEPVsbW1t57zW0tLCm2++SX19PStXruSJJ57AYDDw4osvjulYuLm54eHhgcFgOO+1YzabCQsL47777uOWW2753KdNCiHEeHbj/GLdQCoqKjh58iROp1OZOhIcHExkZCSJiYl0d3cr78OZRJnd3d3KkGdXQOFyGoTx8fHExMSwbt06mpqaSE9PR6VS4e3tTVpaGkePHlUaKa550ikpKeckID07oAFnfrhNJhMvvPACq1atwm63c/jwYRoaGnA6nXh7ezNt2jQKCgoYGhoCzgQm8vLylP2fPHmy8hTC9Z1dDc6xTDXx8PAgJSWFQ4cOKdtbLBaKiooIDAwkJCREecLf1taGw+HAbrdz8uRJ+vv7cTqduLu74+XldU5nu6SkhPr6ehwOh5KENDIyktDQUHx8fGhqalLKcK1C4fperjLPDvZ8WkhICBaL5ZJ1GRERwQMPPEBVVRV79uzBZDIpgYm2tjasVitwJt9HY2PjFU/5mTRpEl5eXpw+fVrpeLW0tFBbW6tMQ7mUiooKNBoNzz33HG+//Tbvvvuu8u+JJ55g//79SlJQvV7PiRMnlMBRS0sLLS0to5L9FRYWKisM9ff3U1ZWRlJSEhqNhuPHj9PQ0ICXlxdr167lueeeIygoCL1ef01G6MTExDA0NMSpU6eU41NbW0tHRwdRUVEkJydjtVo5ffq00nivrKykvr4em81GYGAg6enplJeX09fXp9RTXV0dJSUlynV1uRwOhzJC6OwRA58X10owruks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oLKyUl/84hdVX1+vlpYW/ed//qfa2tpUW1vLpsEmSCaTeuONN3T48GHWDZsok8loaGhIy5cv19VXX626ujqzW5rWIpGI9uzZI5/Pp1tuuUXV1dXas2cPe0idY3a7XQsXLtTChQsl/TZE7+zs1Lp165j9YYLh4WEdOnRIc+bM0e23366DBw/queeeU0tLixoaGpgFcg7lcjl1dnaqpaVFq1at0i233KKBgQH95je/0b59+zRr1izG4xwIh8N67bXX9PTTT2toaEhz5syRpPzsj5aWFm3YsEHLli3Ts88+qx07dqipqemMXvMyA+Q9w8PD6ujo0KJFi2S323Xeeeepu7tbg4ODnHibZGBgQD6fT1dccQUbPJqspqZGN998s2pqamS321VWVqbi4mIlk0lmHJigpKRE119/vRoaGvJLXgKBgDweD0vETHLgwAFNTExo4cKFhOYmSqVSGhkZkcfj4aSuAPT39+dfyM6aNUs+n08XX3yxVq5cKa/Xa3Z701I2m1Vra6uOHTumhQsXqr6+3uyW8B63281xywTZbFYTExNKpVL5Tf5LSkpUVlamzs5OJZNJs1ucFpLJpMbHxzV79mytXr36pNv7+/sViURUX18vv9+vmpoadXV1aXx8/Iy+F2/bvicWi8nj8SgUCslms8nr9cpmsykWiymXy3FSYYJFixZp1apV2r9/v1544QWz28H7dHR0KJFIqKysjNkfJhofH9fmzZv1wgsvqL6+XrNnz2YPEBNMTExo3759mj17tsbHxxkDE8ViMfX396u1tVUHDhyQ2+3WxRdfrLVr18rv95vd3rQzMTEhSRoaGtLDDz+srq4u9gAx2fj4uJqbm1VUVKTly5dzvDJJeXm5LrjgAu3evVs/+tGPJE2+7l22bBmzDc4xu90ut9utZDKpo0ePatWqVRofH9c777yjkZERRaNRAttzIBAI6Morr9QVV1yhF154QX19fZImA6pUKiW/36+SkhI5HI78viAnlsh8VJy5vM/73zHyer38sZvsxDRywqfC0tfXpwcffFC1tbVsulkgQqGQxsfH1dPTo+rqapbAnEOZTEZ79+6V2+3WvHnzdPToUfbFMVE4HNbg4GD+RdHw8LCef/55OZ1OrVmzhtmEJujs7NTg4KBmzJih0dFRvfTSS7Lb7br00kt5nWWCrq4u9fb2at68eaqpqTG7nWkr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TUxM6OGHH1ZbW5tWrVolv9+v//qv/5LdblcgEFBTUxMBCAAAAABAkgUDEEk6FD30e+9TVVp1ym01NTX6h3/4h/zn3//+95XNZnXnnXdOmzDjTNjffFkaGfi998v+7b9+6L/9+Z//uW655RYVFRVJkiKRiO677z799Kc/1Z133qna2lpVVVXpjjvuyH9Ne3u7Wltbdc8992jhwoV66KGHNGPGDH3nO99RSUnJ1H8wAAAAAIBlWDIAOduam5vzS12CwaDWrVun0tLS0943k8lo165dam1tVS6X04wZM3TxxRfL4/EokUjo7bffVmVlpd566y3V1NTo4osvVjKZ1Pbt2zU8PJxfytPU1JSfVdLS0pJfLtLc3KxsNqsFCxZoxYoV+QAhkUhox44d6urqyn/fiy66SF6vV5I0ODiol156SZlMRpK0du1azZs3r2CCHr/fr89//vP6xje+oe3bt+tTn/qU4vG4du3apWXLlml8fFybNm1SZ2enXnzxRbW3t2vz5s1KJBLasmWLLr30UgWDQQ0NDWnLli1KpVKSpDVr1mjevHmy2+1qb2/X8PCwksmkjh49qgsvvFDz589XJBLR66+/rsHBQeVyOS1dujQ/mySZTOqNN97Q7NmzdezYMXV3dyubzWr16tWaN29efsZJe3u7duzYkf++7//3TCajvXv36tChQ8pkMqqurtbatWvl9/sL5vcPAAAAAFZDAPIRZDIZ7d69W5s2bVJbW5scDoey2ax6e3v16U9/+pQQJJlM6pVXXtH27dvV1tamXC6n4uJihcNhXXPNNYpGo/rxj3+s5cuXq7m5WcuWLVNTU5O2bNmiV155RZHI5LKSwcFBFRcX64c//KFqamr07LPPas+ePfrEJz6h119/XbFYTB6PR3/7t3+rxYsXK5VKafPmzfrv//5vpdNpSZLNZlM2m9Vll12m7u5uvfTSS9qyZYucTqeSyaSOHTumW2+9taBCkOrqal166aVqbm7WjTfeqL6+Pt1333367ne/q1gspp07d6q/v1+vvvqqJiYm1NraqmQyqR07duiCCy7QxMSEtmzZoi1btshmsymVSuno0aO65ZZbtGDBAr311lt6/PHHdcEFF6i1tVXV1dUqKSnRiy++qF27dml4eFjpdDofOC1fvlyRSET333+/LrjgAmUyGR0+fFj9/f1qaWnR1772NVVVVamzs1MPP/ywdu/eLa/Xq3A4rJaWFn3lK19RVVWVXn/9dW3fvl1HjhxRJpNRIBDQ+Pi4rr76agUCgYL5/QMAAACAlRCAfASjo6O6//77df755+uuu+6S2+3Wtm3bdM8992jx4sW66KKLTrp/d3e3fv7zn+srX/mKvvvd78pms2nbtm26//77VV9fr1mzZikSiSgajeonP/lJ/mS5s7NTf/VXf6VFixblZ3xs2LAhf5IuSfv379ff//3f64tf/KIikYi+/vWv69VXX9XChQvV09Ojn/zkJ/rMZz6jW265RQ6HQ88884w6OjqUSCT03HPP6fjx4/rxj3+sYDCocDis73//+3r88cf1ta99TX6/34xf72lVVFTowIEDSiaTJ21su3r1av3d3/2d/uVf/kU/+MEPVFtbK7fbrXg8rm9961sqKirSz372M7W1temHP/yhQqGQotGo7r33Xv3qV7/SHXfcoVwup3379ukb3/iGvv3tb8vhcOi5557Tli1b9J3vfEdz585VJpPRz3/+cz3yyCOaNWtWfobNsWPH9L3vfU+VlZV655139I1vfENHjx5VMBjU888/r0OHDun73/++5s2bp4GBAf30pz/V6OioMpmMHnroId1666369re/raKiIu3YsUMPPPCAamtrtWLFCjmdPCwBAAAAwGicaX0EPT09Ghwc1IYNG+R2uyVNnoivXbtWLS0tWrt27Un3P3LkiMbHx9Xe3q5f/epXkiZnhYyNjWn//v2aOXOmJOn888/P1wsEAvrWt76lTCajPXv26MiRI5qYmFBFRcVJta+77jotWLBANptNgUBADQ0N+SUbR44ckdfr1dVXX53fVPSmm26SJIXDYe3Zs0ezZ8/Wiy++mJ9t4Pf7tWPHDv3FX/yFfD7fx34WQjwe1969e1VTU6PNmzfnfw8ej0c7duzQn/3ZnymXy2nlypWaM2eO7HZ7/ndeWlqqN998U7t27ZI0uVHrgQMH1N3drbq6OknSJz7xCZWVlclms6mmpkZlZWWKRqOKRqPat2+fbrjhBs2ePVt2u13V1dW66667JEmvvPKKRkdH1dnZqaeeeipff2xsTC0tLVq2bBkBCAAAAACcBZxpfQQTExOSJkOKE1wul2pra9XXd+qVZ44fP662tjY988wzJ53UlpWV5U+kpclZDicCh2Qyqbfeekvt7e3atWuXuru7lUgk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';

            let imageDataWorkspace = 'data:image/png;base64,';

            let imageDataModel = 'data:image/png;base64,';

            const count = 1;
            let data = null;
            if (imageSelect <= count && count > 0) {
                data = 'imageData' + String(imageSelect);
            }
            switch(imageSelect) {
                case -1: data = 'imageDataEmpty';
                break;
                case -2: data = 'imageDataWorkspace';
                break;
                case -3: data = 'imageDataModel';
                break;
            }
            let obj = {
                "Data": eval(data),
                "Count": count
            };
            return obj;
        }
    </script>

    <script type="text/javascript">
        function getMetaData() {
            let tab = 'New_Report.html';

            let reportTitle = 'Compare: Run 6: Apps_model1 vs. Run 7: Apps_model1';

            let reportAuthor = 'Dell';

            let reportDate = '25-Nov-2023 16:17:46';

            let reportMLV = 'R2022b';

            let comparisonLabel = 'Comparisons';

            let propertiesLabel = 'Properties';

            let baselineLabel = 'Baseline';

            let compareToLabel = 'Compare To';

            let summaryLabel = 'Summary';

            let interactiveLabel = 'Interactive';

            let printableLabel = 'Printable';

            let rowsToReport = 'ReportAllSignals';

            let colsToReport = ['SignalName1', 'AbsTol', 'RelTol', 'MaxDifference', 'Result', 'LinkToPlot'];

            let matched = 'Match';

            let unmatched = 'Mismatch';

            let unmatchedEmptySynced = 'Empty after synchronization';

            let empty = 'Empty original signals';

            let canceled = 'Canceled';

            let unsupported = 'Not supported';

            let datatypeMismatch = 'Mismatched data types';

            let timeMismatch = 'Mismatched time vectors';

            let startstopMismatch = 'Mismatched start and stop times';

            let notCompared = 'Not compared';

            let unaligned = 'Unaligned';

            let unprocessed = 'Unprocessed comparison';

            let unknownStatus = 'Unknown comparison status';

            let processingComparison = 'Comparison in progress';

            let unitsMismatch = 'Mismatched units';

            let emptyBaseline = 'Signal contains no data';

            let unitsMismatchStatus = 'Units do not match';

            let datatypesMismatchStatus = 'Data types do not match';

            let unalignedStatus = 'Matching signal Arg1 could not be found in Arg2';

            let canceledStatus = 'Comparison canceled';

            let timeMismatchStatus = 'Time vectors do not match';

            let startStopTimesMismatchStatus = 'Start and/or stop times do not match';

            let unsupportedStatus = 'Signal not supported for comparison';

            let emptySyncedStatus = 'Signal is empty over comparison interval';

            let emptySignalsStatus = 'Both baseline and compare to have no data';

            let propertyNames = ['Name', 'Description', 'Line', 'Override Global Tolerance',
                'Absolute Tolerance', 'Relative Tolerance', 'Time Tolerance', 'Units', 'Data Type', 'Sample Time',
                'Run', 'Align By', 'Model', 'Block Name', 'Block Path', 'Port', 'Dimensions', 'Channel', 
                'Interp Method', 'Sync Method', 'Time Series Root', 'Time Source', 'Data Source'];

            let propertyIds = ['Name', 'Description', 'Line', 'Override Global Tolerance',
                'Absolute Tolerance', 'Relative Tolerance', 'Time Tolerance', 'Units', 'Data Type', 'Sample Time',
                'Run', 'Align By', 'Model', 'Block Name', 'Block Path', 'Port', 'Dimensions', 'Channel', 
                'Interp Method', 'Sync Method', 'Time Series Root', 'Time Source', 'Data Source'];

            let propertyVars = ['SignalName', 'SignalDescription', 'LineColor', 'OverrideGlobalTol',
                'AbsTol', 'RelTol', 'TimeTol', 'Units', 'SigDataType', 'SigSampleTime',
                'Run', 'AlignBy', 'Model', 'BlockName', 'BlockPath', 'Port', 'Dimensions', 'Channel', 
                'InterpMethod', 'SyncMethod', 'TimeSeriesRoot', 'TimeSource', 'DataSource'];

            let combinedNames = [];
            let combinedIds = [];
            let combinedVars = [];

            combinedNames = combinedNames.concat(propertyNames.slice(0, 1),
                ['Result', 'Max Difference'], propertyNames.slice(2, propertyNames.length));

            combinedIds = combinedIds.concat(propertyIds.slice(0, 1),
                ['Result', 'Max Diff'], propertyIds.slice(2, propertyIds.length));

            combinedVars = combinedVars.concat(propertyVars.slice(0, 1),
                ['Result', 'MaxDifference'], propertyVars.slice(2, propertyVars.length));

            let colHeaders = ['Name (Base)', 'Abs Tol', 'Rel Tol', 'Max Diff',
                'Result', 'Name', 'Comp', 'Block Path (Base)', 'Block Path (Comp)',
                'Data Src (Base)', 'Data Src (Comp)', 'Block Name (Base)',
                'Block Name (Comp)', 'Description', 'Sync Method', 'Interp Method',
                'Run (Base)', 'Run (Comp)', 'Align By', 'Channel (Base)', 'Channel (Comp)',
                'Model (Base)', 'Model (Comp)', 'Dimensions (Base)', 'Dimensions (Comp)',
                'Time Series Root (Base)', 'Time Series Root (Comp)', 'Time Source (Base)',
                'Time Source (Comp)', 'Line Color (Base)', 'Line Color (Comp)',
                'Line Dashed (Base)', 'Line Dashed (Comp)', 'Port (Base)', 'Port (Comp)',
                'Units (Base)', 'Units (Comp)', 'Data Type (Base)', 'Data Type (Comp)',
                'Sample Time (Base)', 'Sample Time (Comp)', 'Time Tol', 'Override Global Tol'];

            let colNames = ['SignalName', 'AbsTol1', 'RelTol1', 'MaxDifference', 'Result',
                'SignalName2', 'BlockPath1', 'BlockPath2', 'DataSource1', 'DataSource2',
                'BlockName1', 'BlockName2', 'SignalDescription1', 'SyncMethod1',
                'InterpMethod1', 'Run1', 'Run2', 'AlignBy1', 'Channel1', 'Channel2',
                'Model1', 'Model2', 'Dimensions1', 'Dimensions2', 'TimeSeriesRoot1',
                'TimeSeriesRoot2', 'TimeSource1', 'TimeSource2', 'LineColor1', 'LineColor2',
                'LineDashed1', 'LineDashed2', 'Port1', 'Port2', 'Units1', 'Units2',
                'SigDataType1', 'SigDataType2', 'SigSampleTime1', 'SigSampleTime2', 'TimeTol1',
                'OverrideGlobalTol1'];

            let obj = {
                "TabTitle": tab,
                "ReportTitle": reportTitle,
                "ReportAuthor": reportAuthor,
                "ReportDate": reportDate,
                "ReportMatlabVersion": reportMLV,
                "ComparisonLabel": comparisonLabel,
                "PropertiesLabel": propertiesLabel,
                "BaselineLabel": baselineLabel,
                "CompareToLabel": compareToLabel,
                "SummaryLabel": summaryLabel,
                "InteractiveLabel": interactiveLabel,
                "PrintableLabel": printableLabel,
                "RowsToReport": rowsToReport,
                "ColumnsToReport": colsToReport,
                "ColumnHeaders": colHeaders,
                "ColumnNames": colNames,
                "PropertyNames": propertyNames,
                "PropertyIds": propertyIds,
                "PropertyVars": propertyVars,
                "CombinedNames": combinedNames,
                "CombinedIds": combinedIds,
                "CombinedVars": combinedVars,
                "MatchedTip": matched,
                "UnmatchedTip": unmatched,
                "UnmatchedEmptySyncedTip": unmatchedEmptySynced,
                "EmptyTip": empty,
                "CanceledTip": canceled,
                "UnsupportedTip": unsupported,
                "DatatypeMismatchTip": datatypeMismatch,
                "TimeMismatchTip": timeMismatch,
                "StartStopMismatchTip": startstopMismatch,
                "NotComparedTip": notCompared,
                "UnalignedTip": unaligned,
                "UnprocessedTip": unprocessed,
                "UnknownStatusTip": unknownStatus,
                "ProcessingComparisonTip": processingComparison,
                "UnitsMismatchTip": unitsMismatch,
                "EmptyBaselineTip": emptyBaseline,
                "UnitsMismatchStatus": unitsMismatchStatus,
                "DatatypesMismatchStatus": datatypesMismatchStatus,
                "UnalignedStatus": unalignedStatus,
                "CanceledStatus": canceledStatus,
                "TimeMismatchStatus": timeMismatchStatus,
                "StartStopTimesMismatchStatus": startStopTimesMismatchStatus,
                "UnsupportedStatus": unsupportedStatus,
                "EmptySyncedStatus": emptySyncedStatus,
                "EmptySignalsStatus": emptySignalsStatus,
            };
            return obj;
        }
    </script>

    <script type="text/javascript">
        function getJSON() {
            var dataJSON =
                [                    {                        "Index": 1,                        "SignalName": "pot_voltage_output",                        "Result": "WithinTolerance",                        "BlockPath1": "Apps_model1/pot_voltage_output",                        "BlockPath2": "Apps_model1/pot_voltage_output",                        "DataSource1": "out.find('yout')(:,1)",                        "DataSource2": "out.find('yout')(:,1)",                        "SignalName1": "pot_voltage_output (Run 6: Apps_model1)",                        "SignalName2": "pot_voltage_output (Run 7: Apps_model1)",                        "ComparisonSignalID": 455,                        "SignalDescription1": "",                        "SignalDescription2": "",                        "AbsTol1": 0,                        "AbsTol2": 0,                        "RelTol1": "0.00%",                        "RelTol2": "0.00%",                        "SyncMethod1": "union",                        "SyncMethod2": "union",                        "InterpMethod1": "zoh",                        "InterpMethod2": "zoh",                        "Run1": "Run 6: Apps_model1",                        "CompareToRunName": "Run 7: Apps_model1",                        "StartTime1": 0,                        "StopTime1": 0,                        "StartTime2": 0,                        "StopTime2": 0,                        "Run2": "Run 7: Apps_model1",                        "Channel1": [],                        "Channel2": [],                        "Model1": "",                        "Model2": "",                        "BlockName1": "pot_voltage_output",                        "BlockName2": "pot_voltage_output",                        "Dimensions1": "[1]",                        "Dimensions2": "[1]",                        "TimeSeriesRoot1": "out.find('yout')",                        "TimeSeriesRoot2": "out.find('yout')",                        "TimeSource1": "out.find('tout')",                        "TimeSource2": "out.find('tout')",                        "LineColor1": [                            0,                            0.44705882352941179,                            0.74117647058823533                        ],                        "LineColor2": [                            0.85098039215686272,                            0.32549019607843138,                            0.098039215686274508                        ],                        "LineDashed1": "-",                        "LineDashed2": "-",                        "Port1": 0,                        "Port2": 0,                        "AlignBy1": "",                        "AlignBy2": "",                        "Units1": "",                        "Units2": "",                        "SigDataType1": "double",                        "SigDataType2": "double",                        "SigSampleTime1": "",                        "SigSampleTime2": "",                        "MaxDifference": 4.4408920985006262E-16,                        "TimeTol1": 0,                        "TimeTol2": 0,                        "OverrideGlobalTol1": "no",                        "OverrideGlobalTol2": "no"                    }                ];
            return dataJSON;
        }        function getGroupJSON() {
            var dataGroupJSON =
                [                    {                        "Index": 0,                        "Level": 0,                        "SignalID": 396,                        "SignalName": "Compare Run 7: Apps_model1 to Run 6: Apps_model1",                        "Type": "run",                        "parentIndex": -1                    },                    {                        "Index": 1,                        "Level": 1,                        "SignalID": 455,                        "SignalName": "pot_voltage_output",                        "Type": "signal",                        "parentIndex": 0                    }                ];
            return dataGroupJSON;
        }
    </script>

    <script type="text/javascript">
        let defaultSignal = 0;
        let currentSignal = 0;
        let isEastWestActive = false;
        let isNorthSouthActive = false;
        let interactLevel;
        let printLevel;
        let headerLevel;
        let verticalSep;
        let horizontalSep;
        let countDrag = 0;
        let interactLevelBorderWidth;
        let signalsHeight;
        let dragbarHeight;
        let propHeight;
        let signalsWidth;
        let dragbarWidth;
        let visualsWidth;
        let isInitNS = true;
        // used for resizing columns
        const minColWidth = 30;
        const colBufferValue = 5;
        const maxCmprColIndex = 4;
        const ABS_TOL = 1;
        const REL_TOL = 2;
        const MAX_DIFF = 3;
        let propRows = [];
        let cmprRows = [];
        let propColumns = [];
        let cmprColumns = [];
        let propHeaderBeingResized = null;
        let cmprHeaderBeingResized = null;

        const metaData = getMetaData();
        const propertyNames = metaData.PropertyNames;
        const propertyIds = metaData.PropertyIds;
        const propertyVars = metaData.PropertyVars;
        const combinedNames = metaData.CombinedNames;
        const combinedIds = metaData.CombinedIds;
        const combinedVars = metaData.CombinedVars;
        const localJSON = getJSON();
        let prevSortedColIndex = -1;
        let asc = 1;
        const localGroupJSON = getGroupJSON();

        const compareFailStr =
            '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
            'title="' + metaData.UnmatchedTip + '">&#10006</span>';

        const notComparedEmptySyncedStr =
            '<span class="cmpr-status-common cmpr-status-notAligned" ' +
            'title="' + metaData.UnmatchedEmptySyncedTip + '">&#8211</span>';

        const compareFailDatatypeStr =
            '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
            'title="' + metaData.DatatypeMismatchTip + '">&#10006</span>';

        const compareFailTimeStr =
            '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
            'title="' + metaData.TimeMismatchTip + '">&#10006</span>';

        const compareFailStartStopStr =
            '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
            'title="' + metaData.StartStopMismatchTip + '">&#10006</span>';

        const compareFailUnitsStr =
            '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
            'title="' + metaData.UnitsMismatchTip + '">&#10006</span>';

        const notComparedUnsupportedStr =
            '<span class="cmpr-status-common cmpr-status-notAligned" ' +
            'title="' + metaData.UnsupportedTip + '">&#8211</span>';

        const compareUnalignedStr =
            '<span class="cmpr-status-common cmpr-status-notAligned" ' +
            'title="' + metaData.UnalignedTip + '">&#8211</span>';

        const compareNotComparedStr =
            '<span class="cmpr-status-common cmpr-status-notAligned" ' +
            'title="' + metaData.NotComparedTip + '">&#8211</span>';

        const comparePassStr =
            '<span class="cmpr-status-common cmpr-status-withinTolerance" ' +
            'title="' + metaData.MatchedTip + '">&#10004</span>';

        const comparePassEmptyStr =
            '<span class="cmpr-status-common cmpr-status-withinTolerance" ' +
            'title="' + metaData.EmptyTip + '">&#10004</span>';

        const compareCanceledStr =
             '<span class="cmpr-status-common cmpr-status-notAligned" ' +
             'title="' + metaData.CanceledTip + '">&#8211</span>';

        if (isValidDataSet(localJSON)) {
            window.addEventListener("resize", maintainPaneAspectRatios);
        }

        window.onload = () => {
            headerLevel = document.getElementById("header");
            interactLevel = document.getElementById("interactive");
            printLevel = document.getElementById("printable");

            if (isGroupingEnabled && localGroupJSON.length !== 0) {
                myMain(localJSON, localGroupJSON);
            } else {
                myMain(localJSON);
            }
            initReportStyle();
            if (isValidDataSet(localJSON)) {
                horizontalSep = document.querySelector("#interactive .horizontal-sep");
                verticalSep = document.querySelector("#interactive .vertical-sep");

                interactLevelBorderWidth = (interactLevel.offsetHeight - interactLevel.clientHeight) / 2;
                if (isSortingEnabled) {
                    addEventListenersForCmprHeaders();
                }
                document.querySelectorAll('.cmpr-hdr-col').forEach(header => {
                    cmprColumns.push({
                        header,
                        size: 0
                    });
                    if (header.querySelector('.cmpr-resize-handle')) {
                        header.querySelector('.cmpr-resize-handle').addEventListener('mousedown', startCmprResize);
                    }
                });
                document.querySelectorAll('.prop-hdr-col').forEach(header => {
                    propColumns.push({
                        header,
                        size: 0
                    });
                    if (header.querySelector('.prop-resize-handle')) {
                        header.querySelector('.prop-resize-handle').addEventListener('mousedown', startPropResize);
                    }
                });

                document.querySelectorAll('.prop-grid').forEach(row => {
                    propRows.push(row);
                });
                document.querySelectorAll('.cmpr-grid').forEach(row => {
                    cmprRows.push(row);
                });

                document.addEventListener("mouseup", endDrag);
                interactLevel.addEventListener("mousemove", onDrag);
                verticalSep.addEventListener("mousedown", eastWestSelect);
                horizontalSep.addEventListener("mousedown", northSouthSelect);
                document.addEventListener("keydown", function (event) {
                    if ((event.key === "ArrowDown") || (event.key === "ArrowUp") ||
                        (event.key === "End") || (event.key === "Home") ||
                        (event.key === "PageDown") || (event.key === "PageUp") ||
                        (event.key === " ")) {
                        event.preventDefault();
                    }
                    if (!event.repeat) {
                        switch (event.key) {
                            case "ArrowDown":
                                var currentCmprRows = getCurrentComparisonTable();
                                var currentHighlightedSignal = getCurrentHighlightedSignal(currentCmprRows);
                                expectedSignal = Math.min(currentHighlightedSignal + 1, localGroupJSON.length - 1);
                                highlightSignalDownwardDirection(expectedSignal, currentCmprRows)
                                moveIntoView(false);
                                break;
                            case "ArrowUp":
                                var currentCmprRows = getCurrentComparisonTable();
                                var currentHighlightedSignal = getCurrentHighlightedSignal(currentCmprRows);
                                expectedSignal = Math.max(currentHighlightedSignal - 1, 0);
                                highlightSignalUpwardDirection(expectedSignal, currentCmprRows)
                                moveIntoView(true);
                                break;
                            case "End":
                                highlightLastSignalInTable();
                                break;
                            case "Home":
                                highlightFirstSignalInTable();
                                break;
                            case "PageDown":
                                var currentCmprRows = getCurrentComparisonTable();
                                var currentHighlightedSignal = getCurrentHighlightedSignal(currentCmprRows);
                                var expectedSignal = Math.max(firstHidden(true), currentHighlightedSignal);
                                highlightSignalDownwardDirection(expectedSignal, currentCmprRows);
                                moveIntoView(true);
                                break;
                            case "PageUp":
                                var currentCmprRows = getCurrentComparisonTable();
                                var currentHighlightedSignal = getCurrentHighlightedSignal(currentCmprRows);
                                expectedSignal = Math.min(firstHidden(false), currentHighlightedSignal);
                                highlightSignalUpwardDirection(expectedSignal, currentCmprRows);
                                moveIntoView(false);
                                break;
                            case " ":
                                var currentCmprRows = getCurrentComparisonTable();
                                var currentHighlightedSignal = getCurrentHighlightedSignal(currentCmprRows);
                                expectedSignal = Math.min(currentHighlightedSignal + 1, localGroupJSON.length - 1);
                                highlightSignalDownwardDirection(expectedSignal, currentCmprRows);
                                moveIntoView(false);
                        }
                    }
                });
                setResultsPane();
            }
        };

        function highlightSignalDownwardDirection (expectedSignal, currentCmprRows) {
            if (expectedSignal >= currentCmprRows.length - 1) {
                highlightLastSignalInTable();
            } else {
                var lastSignal = getCurrentLastSignalInTable();
                while (currentCmprRows[expectedSignal] && currentCmprRows[expectedSignal].classList.contains('row-display-off')) {
                    expectedSignal += 1;
                    if (expectedSignal > lastSignal) {
                        expectedSignal = lastSignal;
                        break;
                    }
                }
                var index = getSignalIndexFromOriginalTable(expectedSignal);
                rowClickDisplay(index, expectedSignal);
            }
        }

        function highlightSignalUpwardDirection (expectedSignal, currentCmprRows) {
            if (expectedSignal <= 0) {
                highlightFirstSignalInTable();
            } else {
                var firstSignal = getCurrentFirstSignalInTable();
                while (currentCmprRows[expectedSignal] && currentCmprRows[expectedSignal].classList.contains('row-display-off')) {
                    expectedSignal -= 1;
                    if (expectedSignal < firstSignal) {
                        expectedSignal = firstSignal;
                        break;
                    }
                }
                var index = getSignalIndexFromOriginalTable(expectedSignal);
                rowClickDisplay(index, expectedSignal);
            }
        }

        function highlightLastSignalInTable () {
            var expectedSignal = getCurrentLastSignalInTable();
            var index = getSignalIndexFromOriginalTable(expectedSignal);
            rowClickDisplay(index, expectedSignal);
            moveIntoView(false);
        }

        function highlightFirstSignalInTable () {
            var expectedSignal = getCurrentFirstSignalInTable();
            var index = getSignalIndexFromOriginalTable(expectedSignal);
            rowClickDisplay(index, expectedSignal);
            moveIntoView(true);
        }

        function getSignalIndexFromOriginalTable (expectedSignal) {
            // calculating the corresponding position in the original table whose index can be used to display the right values in properties table and in plot
            var currentCmprRows = getCurrentComparisonTable();
            for (var index = 0; index < window.defaultCompTable.length; index++) {
                if (currentCmprRows[expectedSignal].isSameNode(window.defaultCompTable[index])) break;
            }
            return index;
        }

        function getCurrentLastSignalInTable () {
            var cmprRows = getCurrentComparisonTable();
            var lastVisibleSignalIndex = cmprRows.length - 1;
            // iterating to find the last visible signal node in current state of table
            while (cmprRows[lastVisibleSignalIndex].classList.contains('row-display-off')) {
                lastVisibleSignalIndex = lastVisibleSignalIndex - 1;
            }
            return lastVisibleSignalIndex;
        }

        function getCurrentFirstSignalInTable () {
            var firstVisibleSignalIndex = 0;
            var cmprRows = getCurrentComparisonTable();
            // iterating to find the first visible signal node in current state of table
            while (cmprRows[firstVisibleSignalIndex].classList.contains('row-display-off')) {
                firstVisibleSignalIndex = firstVisibleSignalIndex + 1;
            }
            return firstVisibleSignalIndex;
        }

        function getCurrentComparisonTable () {
            var cmprRows = [];
            document.querySelectorAll('.cmpr-grid').forEach(row => {
                cmprRows.push(row);
            });
            return cmprRows.slice(1);
        }

        function getCurrentHighlightedSignal (currentCmprRows) {
            let index = 0;
            while (!currentCmprRows[index].classList.contains('cmpr-row-selected')) {
                index = index + 1;
                if (index === currentCmprRows.length - 1) break;
            }
            return index;
        }

        function startPropResize ({ target }) {
            propHeaderBeingResized = target.parentNode;
            window.addEventListener('mousemove', propTblMouseMove);
            window.addEventListener('mouseup', propTblMouseUp);
            propHeaderBeingResized.classList.add('prop-header-being-resized');
            document.querySelectorAll('.prop-grid').forEach(row => {
                propRows.push(row);
                event.preventDefault();
            });
        }

        function propTblMouseMove (e) {
            if (propHeaderBeingResized) {
                computePrevTableSize(propColumns, '.prop-hdr-col');
                let width = computeWidth(e, propHeaderBeingResized);
                const resizedColIndex = propColumns.findIndex(({ header }) => header === propHeaderBeingResized);
                adjustWidth(propColumns, resizedColIndex, width);
                propRows.forEach(row => {
                    row.style.gridTemplateColumns = propColumns.map(({ header, size }) => size).join(' ');
                });
            }
        }

        function propTblMouseUp () {
            if (propHeaderBeingResized) {
                window.removeEventListener('mousemove', propTblMouseMove);
                window.removeEventListener('mouseup', propTblMouseUp);
                propHeaderBeingResized.classList.remove('prop-header-being-resized');
                propHeaderBeingResized = null;
                propRows = [];
            }
            event.stopPropagation();
        }

        function computePrevTableSize (columns, selector) {
            let i = 0;
            let prevCols = document.querySelectorAll(selector);
            for (i = 0; i < prevCols.length; i++) {
                columns[i].size = prevCols[i].offsetWidth;
            }
        }

        function adjustWidth (columns, resizedColIndex, width) {
            let currentLeftPanelWidth = document.querySelectorAll('.vertical-sep')[0].offsetLeft - 10;
            columns[resizedColIndex + 1].size = Math.max(minColWidth, (columns[resizedColIndex].size + columns[resizedColIndex + 1].size) - Math.max(minColWidth, width));
            columns[resizedColIndex].size = Math.max(minColWidth, width);
            let totalColSize = 0;
            columns.forEach(col => {
                totalColSize = totalColSize + col.size;
            });
            // colBufferValue denotes the extra spacing between the last column in the table and the vertical line beside the graphs
            totalColSize = totalColSize + colBufferValue;
            if (totalColSize > currentLeftPanelWidth) {
                width = width - (totalColSize - currentLeftPanelWidth);
                columns[resizedColIndex].size = Math.max(minColWidth, width);
            }
            columns.forEach(col => {
                col.size = col.size + 'px';
            });
        }

        function computeWidth (e, header) {
            let horizontalScrollOffset = document.documentElement.scrollLeft;
            let width = horizontalScrollOffset + e.clientX - header.offsetLeft;
            return width;
        }

        function startCmprResize ({ target }) {
            cmprHeaderBeingResized = target.parentNode;
            window.addEventListener('mousemove', cmprTblMouseMove);
            window.addEventListener('mouseup', cmprTblMouseUp);
            cmprHeaderBeingResized.classList.add('cmpr-header-being-resized');
            document.querySelectorAll('.cmpr-grid').forEach(row => {
                cmprRows.push(row);
                event.preventDefault();
            });
        }

        function cmprTblMouseMove (e) {
            if (cmprHeaderBeingResized) {
                computePrevTableSize(cmprColumns, '.cmpr-hdr-col');
                let width = computeWidth(e, cmprHeaderBeingResized);
                let resizedCmprColIndex = cmprColumns.findIndex(({ header }) => header === cmprHeaderBeingResized);
                adjustWidth(cmprColumns, resizedCmprColIndex, width);
                cmprRows.forEach(row => {
                    row.style.gridTemplateColumns = cmprColumns.map(({ header, size }) => size).join(' ');
                });
            }
        }

        function cmprTblMouseUp () {
            if (cmprHeaderBeingResized) {
                window.removeEventListener('mousemove', cmprTblMouseMove);
                window.removeEventListener('mouseup', cmprTblMouseUp);
                cmprHeaderBeingResized.classList.remove('cmpr-header-being-resized');
                cmprHeaderBeingResized = null;
                cmprRows = [];
            }
            event.stopPropagation();
        }

        function addTooltips () {
            var comparisonRows = document.querySelectorAll('.cmpr-row');
            for (var i = 0; i < comparisonRows.length; i++) {
                var row = comparisonRows[i];
                var columns = row.querySelectorAll('td');
                // the result column already has tooltips with static text in their tags so no need to include it here
                // hence the j loop here runs only till the MAX DIFF column
                for (var j = 0; j <= MAX_DIFF; j++) {
                    // a group node does not have text in all the columns, in such case a tooltip not required
                    if (columns[j].innerText !== '') {
                        var text = columns[j].innerText;
                        columns[j].setAttribute('title', text);
                    }
                }
            }
        }

        function myMain(passedData, localGroupJSON) {
            makeHeaderStructure();
            setHeaderData();
            if (isValidDataSet(passedData)) {
                makeInteractiveStructure();
                makePrintableStructure(passedData.length);
                if (isGroupingEnabled && typeof localGroupJSON !== 'undefined') {
                    makeComparisonTable(passedData, localGroupJSON);
                } else {
                    makeComparisonTableWithoutGrouping(passedData);
                }
                addTooltips();
                makePropertiesTable();
                fillPropertiesTable(defaultSignal);
                dispImage(defaultSignal, 'interactive', 'visuals', '', document);
                if (isGroupingEnabled && typeof localGroupJSON !== 'undefined') {
                    let defaultNode = filterDataByField(localGroupJSON, passedData[0]['ComparisonSignalID'], 'SignalID');
                    highlightRow(defaultNode[0]['Index'] - 1);
                    fillSummary(passedData);
                    fillCombinedRow();
                    addEventListenersForHighlightRow();
                } else {
                    highlightRow(defaultSignal);
                    fillSummary(passedData);
                    fillCombinedRow();
                }
            } else {
                noMismatchedSignals();
            }
        }

        function moveIntoView(align) {
            let elem = document.querySelector("#interactive .cmpr-row-selected");
            let prnt = document.querySelector("#interactive .sig-data");
            let elemRect = elem.getBoundingClientRect();
            let prntRect = prnt.getBoundingClientRect();
            if (elemRect.top < prntRect.top || elemRect.bottom > prntRect.bottom ||
                elemRect.right > prntRect.right || elemRect.left < prntRect.left) {
                elem.scrollIntoView(align);
            }
        }

        function firstHidden(downDir) {
            let listNodes = document.querySelectorAll("#interactive .cmpr-row, .cmpr-row-selected");
            let elems = Array.prototype.slice.call(listNodes, 0);
            let elemRect;
            let prnt = document.querySelector("#interactive .sig-data");
            let prntRect = prnt.getBoundingClientRect();
            let hit = false;
            let curIndex;
            if (downDir) {
                curIndex = elems.length - 1;
                elems.forEach(function (elem, index) {
                    if (elem.classList.contains('row-display-off')) return;
                    elemRect = elem.getBoundingClientRect();
                    if (!hit || false) {
                        if (elemRect.bottom - 1 > prntRect.bottom) {
                            hit = true;
                            curIndex = index;
                        }
                    }
                });
            } else {
                curIndex = null;
                elems.reverse();
                elems.forEach(function (elem, index) {
                    if (elem.classList.contains('row-display-off')) return;
                    elemRect = elem.getBoundingClientRect();
                    if (!hit || false) {
                        if (elemRect.top < prntRect.top) {
                            hit = true;
                            curIndex = elems.length - 1 - index;
                        }
                    }
                });
            }
            return (curIndex);
        }

        function setHeaderData() {
            document.title = metaData.TabTitle;
            const reportTitle = document.querySelector('#header .report-title');
            const reportAuthor = document.querySelector('#header .report-author');
            const reportDate = document.querySelector('#header .report-date');
            const reportMLV = document.querySelector('#header .report-version');

            reportTitle.innerHTML = metaData.ReportTitle;
            reportAuthor.innerHTML = metaData.ReportAuthor;
            reportDate.innerHTML = metaData.ReportDate;
            reportMLV.innerHTML = metaData.ReportMatlabVersion;
        }

        function makeTable(containerName, tableName, tableType, contentName) {
            let container = document.createElement('div');
            container.className = containerName;
            let table = document.createElement('table');
            table.className = tableName;
            let content = document.createElement(tableType);
            content.className = contentName;
            container.appendChild(table);
            table.appendChild(content);
            return (container)
        }

        function makeDiv(className, idName) {
            let container = document.createElement('div');
            if (idName) {
                container.id = idName;
            }
            container.className = className;
            return (container)
        }

        function noMismatchedSignals() {
            let noSigsInter = makeDiv('no-signals');
            let noSigsPrint = makeDiv('no-signals');
            interactLevel.appendChild(noSigsInter);
            printLevel.appendChild(noSigsPrint);
            let signalNameMessage = localJSON[0]["SignalName"];
            noSigsInter.innerHTML = signalNameMessage;
            noSigsPrint.innerHTML = signalNameMessage;
        }

        function makeInteractiveStructure() {
            let sigContainer = makeDiv('signals');
            let horizontalSep = makeDiv('horizontal-sep');
            let propContainer = makeDiv('properties');
            let verticalSep = makeDiv('vertical-sep');
            let visContainer = makeDiv('visuals');
            interactLevel.appendChild(sigContainer);
            interactLevel.appendChild(horizontalSep);
            interactLevel.appendChild(propContainer);
            interactLevel.appendChild(verticalSep);
            interactLevel.appendChild(visContainer);

            let sigHderTbl = makeTable('sig-header', 'cmpr-tbl-common', 'thead', 'cmpr-tbl-hdr-content');
            let sigBdyTbl = makeTable('sig-data', 'cmpr-tbl-common', 'tbody', 'cmpr-tbl-bdy-content');
            let sigScroll = makeDiv('sig-scroll');
            sigContainer.appendChild(sigHderTbl);
            sigContainer.appendChild(sigBdyTbl);
            sigContainer.appendChild(sigScroll);

            let propTitle = makeDiv('prop-title unselectable');
            let propHderTbl = makeTable('prop-header unselectable', 'prop-tbl-common', 'thead', 'prop-tbl-hdr-content');
            let propBdyTbl = makeTable('prop-data unselectable', 'prop-tbl-common prop-data-tbl', 'tbody', 'prop-tbl-bdy-content');
            let propScroll = makeDiv('prop-scroll');
            propContainer.appendChild(propTitle);
            propContainer.appendChild(propHderTbl);
            propContainer.appendChild(propBdyTbl);
            propContainer.appendChild(propScroll);
        }

        function makePrintableStructure(numRows) {
            let summaryHdr = makeDiv('summary-label');
            let summaryData = makeDiv('summary-data');
            let summaryContainer = makeDiv('summary');
            let resultsContainer = makeDiv('results');
            summaryContainer.appendChild(summaryHdr);
            summaryContainer.appendChild(summaryData);
            printLevel.appendChild(summaryContainer);
            printLevel.appendChild(resultsContainer);

            let resultsHdr = makeDiv('results-label');
            let resultsRow = makeDiv('results-row');
            let combContainer = makeDiv('signals-n-properties');
            let visContainer = makeDiv('print-visuals');
            let sigSumHderTbl = makeTable('print-sig-header', 'print-summary-common header-data', 'thead', 'cmpr-tbl-hdr-content');
            let sigSumBdyTbl = makeTable('print-sig-data', 'print-summary-common bdy-data', 'tbody', 'cmpr-tbl-bdy-content');
            let sigSumBlank = makeDiv('print-blank');
            let combHderTbl = makeTable('sig-prop-header unselectable', 'print-summary-common header-data', 'thead', 'prop-tbl-hdr-content');
            let combBdyTbl = makeTable('sig-prop-data unselectable', 'print-summary-common bdy-data', 'tbody', 'prop-tbl-bdy-content');

            summaryData.appendChild(sigSumHderTbl);
            summaryData.appendChild(sigSumBdyTbl);
            summaryData.appendChild(sigSumBlank);

            for (let rowIndex = 1; rowIndex < numRows + 1; rowIndex++) {
                if (rowIndex === 1) {
                    resultsContainer.appendChild(resultsRow);
                    resultsRow.appendChild(resultsHdr);
                    resultsRow.appendChild(combContainer);
                    resultsRow.appendChild(visContainer);

                    combContainer.appendChild(combHderTbl);
                    combContainer.appendChild(combBdyTbl);
                } else {
                    resultsContainer.appendChild(resultsRow.cloneNode(true));
                    resultsRow.appendChild(resultsHdr);
                    resultsRow.appendChild(combContainer);
                    resultsRow.appendChild(visContainer);
                    combContainer.appendChild(combHderTbl);
                    combContainer.appendChild(combBdyTbl);
                }
            }
        }

        function makeHeaderStructure() {
            let hdrLeft = makeDiv('header-left');
            let hdrRight = makeDiv('header-right');
            let hdrTitle = makeDiv('report-title unselectable');
            let hdrAuthor = makeDiv('report-author unselectable');
            let hdrVersion = makeDiv('report-version unselectable');
            let hdrDate = makeDiv('report-date unselectable');
            let hdrSpace = makeDiv('report-space unselectable');
            let hdrStyle = makeDiv('report-style unselectable');
            hdrLeft.appendChild(hdrTitle);
            hdrLeft.appendChild(hdrAuthor);
            hdrLeft.appendChild(hdrVersion);
            hdrLeft.appendChild(hdrDate);
            hdrLeft.appendChild(hdrSpace);
            hdrRight.appendChild(hdrStyle);
            headerLevel.appendChild(hdrLeft);
            headerLevel.appendChild(hdrRight);
        }

        function constructColumnNames (tableHead, colHeaders, colDispNum) {
            let th, tr, td;
            tr = document.createElement('tr');
            tr.setAttribute('class', 'rowComparisonsHead cmpr-grid');
            for (let colIndex = 0; colIndex < colDispNum; colIndex++) {
                th = document.createElement('th');
                th.setAttribute('class', 'cmpr-cell-hdr common-cell signal-cell unselectable cmpr-hdr-col common-cell-border');
                tr.appendChild(th);
                if (isSortingEnabled) {
                    addSortResizeElements(colHeaders, colIndex, th);
                } else {
                    if (colIndex < maxCmprColIndex) {
                        th.innerHTML = colHeaders[colIndex].concat('<span class="cmpr-resize-handle"></span>');
                    } else {
                        th.innerHTML = colHeaders[colIndex];
                    }
                }
            }
            tableHead.appendChild(tr);
        }

        function makeComparisonTable (cmprData, groupData) {
            const tableHead = document.querySelector('#interactive .cmpr-tbl-hdr-content');
            const tableBody = document.querySelector('#interactive .cmpr-tbl-bdy-content');
            const colHeaders = metaData.ColumnHeaders;
            const colNames = metaData.ColumnNames;
            let th, tr, td;
            const colDispNum = 5;
            constructColumnNames(tableHead, colHeaders, colDispNum);

            const compareFailStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.UnmatchedTip + '">&#10006</span>';

            const notComparedEmptySyncedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.UnmatchedEmptySyncedTip + '">&#8211</span>';

            const compareFailDatatypeStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.DatatypeMismatchTip + '">&#10006</span>';

            const compareFailTimeStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.TimeMismatchTip + '">&#10006</span>';

            const compareFailStartStopStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.StartStopMismatchTip + '">&#10006</span>';

            const compareFailUnitsStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.UnitsMismatchTip + '">&#10006</span>';

            const notComparedUnsupportedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.UnsupportedTip + '">&#8211</span>';

            const compareUnalignedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.UnalignedTip + '">&#8211</span>';

            const compareNotComparedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.NotComparedTip + '">&#8211</span>';

            const comparePassStr =
                '<span class="cmpr-status-common cmpr-status-withinTolerance" ' +
                'title="' + metaData.MatchedTip + '">&#10004</span>';

            const comparePassEmptyStr =
                '<span class="cmpr-status-common cmpr-status-withinTolerance" ' +
                'title="' + metaData.EmptyTip + '">&#10004</span>';

            const compareCanceledStr =
                 '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                 'title="' + metaData.CanceledTip + '">&#8211</span>';

            var resultStatusMatched = ['WithinTolerance', 'Empty'];
            var resultStatusMismatched = ['OutOfTolerance', , 'DataTypeMismatch', 'TimeMismatch', 'StartStopMismatch', 'UnitsMismatch'];
            var resultStatusNotCompared = ['Unaligned', 'EmptySynced', 'Unsupported', 'Canceled'];
            var categoryCount = calculateResultCategoryCount(cmprData, resultStatusMatched, resultStatusMismatched, resultStatusNotCompared);

            if (metaData.RowsToReport === 'ReportOnlyMismatchedSignals') {
                groupData = filterMismatchedSignals(cmprData, groupData);
                groupData = adjustIndexes(groupData);
            }
            var firstLevelGroupNodesCount = 0;
            var foundFirstChildSignal = false;
            var firstChildSignalInfo = getFirstChildSignalInfo(groupData);
            // iterating over grouping information
            for (let i = 1; i < groupData.length; i++) {
                var isGroupNode = false;
                var row = groupData[i];
                if (row['parentIndex'] === 0) firstLevelGroupNodesCount += 1;
                tr = document.createElement('tr');
                var paddingCount = row['Level'] - 1;
                // checking if the current row is a group node or not
                if (i !== groupData.length - 1) {
                    if (row['Index'] === groupData[i + 1]['parentIndex']) isGroupNode = true;
                    else {
                        var currentNode = filterDataByField(cmprData, row['SignalID'], 'ComparisonSignalID');
                    }
                } else {
                    // last row in table cannot be a group node so directly extracting the node related information
                    var currentNode = filterDataByField(cmprData, row['SignalID'], 'ComparisonSignalID');
                }
                tr.setAttribute('class', 'cmpr-row cmpr-grid');
                if (!isGroupNode && firstLevelGroupNodesCount === 1) foundFirstChildSignal = true;
                for (let colIndex = 0; colIndex < colDispNum; colIndex++) {
                    td = document.createElement('td');
                    tr.appendChild(td);
                    var name = colNames[colIndex];
                    if (isValidDataSet(cmprData)) {
                        // not displaying the child nodes except for the ones under the first main group node
                        if (paddingCount !== 0 && firstLevelGroupNodesCount > 1) {
                            tr.classList.add('row-display-off');
                        }
                        switch (name) {
                            case "MaxDifference":
                                if (isGroupNode) {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell common-cell-border unselectable');
                                    td.innerHTML = "";
                                } else {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border  unselectable');
                                    if (!currentNode[0].hasOwnProperty(name) || currentNode[0][name] === null) {
                                        td.innerHTML = 'N/A';
                                    } else td.innerHTML = parseFloat(currentNode[0][name]).toFixed(2);
                                    groupData[i][name] = td.innerHTML;
                                }
                                break;
                            case "Result":
                                if (isGroupNode) {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell unselectable');
                                    td.innerHTML = "";
                                } else {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                                    var resultSpaces = getNumberOfSpaces(currentNode[0][name], categoryCount, resultStatusMatched, resultStatusMismatched, resultStatusNotCompared);
                                    groupData[i][name] = {};
                                    switch (currentNode[0][name]) {
                                        case "WithinTolerance":
                                            td.innerHTML = comparePassStr;
                                            groupData[i][name][metaData.MatchedTip] = 1;
                                            break;
                                        case "Empty":
                                            td.innerHTML = comparePassEmptyStr;
                                            groupData[i][name][metaData.EmptyTip] = 1;
                                            break;
                                        case "Unaligned":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareUnalignedStr;
                                            groupData[i][name][metaData.UnalignedTip] = 1;
                                            break;
                                        case "Canceled":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareCanceledStr;
                                            groupData[i][name][metaData.CanceledTip] = 1;
                                            break;
                                        case "EmptySynced":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + notComparedEmptySyncedStr;
                                            groupData[i][name][metaData.UnmatchedEmptySyncedTip] = 1;
                                            break;
                                        case "Unsupported":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + notComparedUnsupportedStr;
                                            groupData[i][name][metaData.UnsupportedTip] = 1;
                                            break;
                                        case "DataTypeMismatch":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareFailDatatypeStr;
                                            groupData[i][name][metaData.DatatypeMismatchTip] = 1;
                                            break;
                                        case "TimeMismatch":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareFailTimeStr;
                                            groupData[i][name][metaData.TimeMismatchTip] = 1;
                                            break;
                                        case "StartStopMismatch":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareFailStartStopStr;
                                            groupData[i][name][metaData.StartStopMismatchTip] = 1;
                                            break;
                                        case "UnitsMismatch":
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareFailUnitsStr;
                                            groupData[i][name][metaData.UnitsMismatchTip] = 1;
                                            break;
                                        default:
                                            td.innerHTML = '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']) + compareFailStr;
                                            groupData[i][name][metaData.UnmatchedTip] = 1;
                                    }
                                }
                                break;
                            case 'SignalName':
                                if (isGroupNode) {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell  unselectable');
                                } else {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                                }
                                if (isGroupNode) {
                                    var currentLeftPadding = 5 + paddingCount * 17;
                                } else {
                                    // as signal node text is displayed from the middle of the grouping hierarchy related icon
                                    var currentLeftPadding = 5 + paddingCount * 17 + 12;
                                }
                                // all child nodes are not displayed by default except for the first level child nodes under the first group node
                                if (paddingCount >= firstChildSignalInfo['Level'] - 1 && row['parentIndex'] !== firstChildSignalInfo['parentIndex']) tr.classList.add('row-display-off');
                                // if the signal names have angular brackets then they are considered as html tags so they are replcaed with character entities, but on the page they are still displayed as the angular brackets as expected by user
                                row[name] = row[name].replace('<', '&lt;');
                                row[name] = row[name].replace('>', '&gt;');
                                // the first group node is expanded all others are collapsed by default
                                if (isGroupNode) {
                                    var groupNodeSpan = document.createElement('span');
                                    groupNodeSpan.setAttribute('style', 'padding-left: ' + currentLeftPadding + 'px;');
                                    groupNodeSpan.setAttribute('class', 'groupCell');
                                    if (firstLevelGroupNodesCount === 1 && !foundFirstChildSignal) {
                                        groupNodeSpan.innerHTML = '<span class = "group"><div class = "group-down-arrow"></div></span>'
                                    } else {
                                        groupNodeSpan.innerHTML = '<span class = "group"><div class = "group-right-arrow"></div></span>';
                                    }
                                    var iconDiv = document.createElement('span');
                                    iconDiv.setAttribute('class', 'groupIcon');
                                    if (row['Type'] === 'datahierarchy') {
                                        iconDiv.appendChild(getGroupIcons(-2));
                                    }
                                    if (row['Type'] === 'subsystems' || row['type'] === 'physmodhierarchy') {
                                        iconDiv.appendChild(getGroupIcons(-3));
                                    }
                                    groupNodeSpan.firstChild.appendChild(iconDiv);
                                    groupNodeSpan.innerHTML += row[name];
                                    td.appendChild(groupNodeSpan);
                                } else {
                                    var signalNodeSpan = document.createElement('span');
                                    signalNodeSpan.setAttribute('style', 'padding-left: ' + currentLeftPadding + 'px;');
                                    signalNodeSpan.innerHTML = row[name];
                                    td.appendChild(signalNodeSpan);
                                }
                                break;
                            default:
                                if (isGroupNode) {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell  unselectable');
                                } else {
                                    td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                                    if (currentNode[0].hasOwnProperty(name)) {
                                        td.innerHTML = currentNode[0][name];
                                        groupData[i][name] = currentNode[0][name];
                                    } else {
                                        td.innerHTML = "";
                                    }
                                }
                        }
                    } else {
                        if (isGroupNode) {
                            td.setAttribute('class', 'cmpr-cell-bdy common-cell   unselectable');
                        } else {
                            td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                        }
                        td.innerHTML = currentNode[0][name];
                        groupData[i][name] = currentNode[0][name];
                    }
                    groupData[i]['node'] = tr;
                    tableBody.appendChild(tr);
                }
            }

            // filling the group nodes result column by iterating over the child nodes
            var cmprBodyRows = Array.from(tableBody.querySelectorAll('tr'));
            for (var i = 1; i < groupData.length; i++) {
                if (groupData[i]['Result'] === undefined) {
                    // passing the group node information
                    fillResultsForGroupNodes(groupData, groupData[i]['Index'], categoryCount);
                }
            }
            removeExtraSpaces(cmprBodyRows);
            addEventListnersForGroupNodes();
            addBordersForGroupNodes();
            window.defaultCompTable = Array.from(tableBody.querySelectorAll('tr'));
        }

        function makeComparisonTableWithoutGrouping (cmprData) {
            const tableHead = document.querySelector('#interactive .cmpr-tbl-hdr-content');
            const tableBody = document.querySelector('#interactive .cmpr-tbl-bdy-content');
            const colHeaders = metaData.ColumnHeaders;
            const colNames = metaData.ColumnNames;

            let th, tr, td;
            const colDispNum = 5;
            constructColumnNames(tableHead, colHeaders, colDispNum);

            const compareFailStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.UnmatchedTip + '">&#10006</span>';

            const notComparedEmptySyncedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.UnmatchedEmptySyncedTip + '">&#8211</span>';

            const compareFailDatatypeStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.DatatypeMismatchTip + '">&#10006</span>';

            const compareFailTimeStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.TimeMismatchTip + '">&#10006</span>';

            const compareFailStartStopStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.StartStopMismatchTip + '">&#10006</span>';

            const compareFailUnitsStr =
                '<span class="cmpr-status-common cmpr-status-signalFailed" ' +
                'title="' + metaData.UnitsMismatchTip + '">&#10006</span>';

            const notComparedUnsupportedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.UnsupportedTip + '">&#8211</span>';

            const compareUnalignedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.UnalignedTip + '">&#8211</span>';

            const compareNotComparedStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.NotComparedTip + '">&#8211</span>';

            const comparePassStr =
                '<span class="cmpr-status-common cmpr-status-withinTolerance" ' +
                'title="' + metaData.MatchedTip + '">&#10004</span>';

            const comparePassEmptyStr =
                '<span class="cmpr-status-common cmpr-status-withinTolerance" ' +
                'title="' + metaData.EmptyTip + '">&#10004</span>';

            const compareCanceledStr =
                '<span class="cmpr-status-common cmpr-status-notAligned" ' +
                'title="' + metaData.CanceledTip + '">&#8211</span>';

            cmprData.forEach(function (row, index) {
                tr = document.createElement('tr');
                tr.setAttribute('class', 'cmpr-row cmpr-grid');
                if (isValidDataSet(cmprData)) {
                    tr.addEventListener('click', rowClickDisplay.bind(tr, index));
                }
                for (var colIndex = 0; colIndex < colDispNum; colIndex++) {
                    td = document.createElement('td');
                    tr.appendChild(td);
                    var name = colNames[colIndex];
                    if (isValidDataSet(cmprData)) {
                        switch (name) {
                            case "MaxDifference":
                                td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                                if (!row.hasOwnProperty(name) || row[name] === null) {
                                    td.innerHTML = 'N/A';
                                } else {
                                    td.innerHTML = parseFloat(row[name]).toFixed(2);
                                }
                                break;
                            case "Result":
                                td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                                if (row[name] === "WithinTolerance") {
                                    td.innerHTML = comparePassStr;
                                } else if (row[name] === "Empty") {
                                    td.innerHTML = comparePassEmptyStr;
                                } else if (row[name] === "Unaligned") {
                                    td.innerHTML = compareUnalignedStr;
                                } else if (row[name] === "Canceled") {
                                    td.innerHTML = compareCanceledStr;
                                } else if (row[name] === "EmptySynced") {
                                    td.innerHTML = notComparedEmptySyncedStr;
                                } else if (row[name] === "Unsupported") {
                                    td.innerHTML = notComparedUnsupportedStr;
                                } else if (row[name] === "DataTypeMismatch") {
                                    td.innerHTML = compareFailDatatypeStr;
                                } else if (row[name] === "TimeMismatch") {
                                    td.innerHTML = compareFailTimeStr;
                                } else if (row[name] === "StartStopMismatch") {
                                    td.innerHTML = compareFailStartStopStr;
                                } else if (row[name] === "UnitsMismatch") {
                                    td.innerHTML = compareFailUnitsStr;
                                } else {
                                    td.innerHTML = compareFailStr;
                                }
                                break;
                            case 'SignalName':
                                td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell  common-cell-border unselectable');
                                var signalNodeSpan = document.createElement('span');
                                signalNodeSpan.textContent = row[name];
                                td.appendChild(signalNodeSpan);
                                break;
                            default:
                                td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                                td.innerHTML = row[name];
                        }
                    } else {
                        td.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable');
                        td.innerHTML = row[name];
                    }
                }
                cmprData[index]['node'] = tr;
                tableBody.appendChild(tr);
            });
            window.defaultCompTable = Array.from(tableBody.querySelectorAll('tr'));
        }

        function addEventListnersForGroupNodes () {
            // to perfom grouping related actions when any of the arrows are clicked
            document.querySelectorAll('.group').forEach(arrow => {
                arrow.addEventListener('click', performGrouping);
            });
        }

        function getFirstChildSignalInfo (groupData) {
            var info = { 'Level': groupData[groupData.length - 1]['Level'], 'parentIndex': groupData[groupData.length - 1]['parentIndex'] };
            for (var i = 0; i < groupData.length - 1; i++) {
                if (groupData[i]['Index'] !== groupData[i + 1]['parentIndex']) {
                    info['Level'] = groupData[i]['Level'];
                    info['parentIndex'] = groupData[i]['parentIndex'];
                    break;
                }
            }
            return info;
        }

        function filterMismatchedSignals (cmprData, groupData) {
            // checking for signals from first level which are not group nodes and deleting accordingly
            for (let i = 1; i < groupData.length - 1; i++) {
                if (groupData[i]['Index'] !== groupData[i + 1]['parentIndex'] && groupData[i]['Level'] === 1) {
                    var node = filterDataByField(cmprData, groupData[i]['SignalID'], 'ComparisonSignalID')
                    if (node.length === 0) {
                        groupData.splice(i, 1);
                        // since an element is removed while splicing the current index in array will point to next one.
                        // Again the index also gets incremented due to 'increment' written for looping variable 'i++'.
                        // Due to this, one element of array is being skipped without being checked, so the below statement ensures
                        // that the current index points to previous element after splicing
                        i = i-1;
                    }
                }
            }
            // checking for the last node separately since it is expected not to be a group node
            var node = filterDataByField(cmprData, groupData[groupData.length-1]['SignalID'], 'ComparisonSignalID')
            if (node.length === 0) {
                groupData.splice(groupData.length - 1, 1);
            }

            // checking for the other signals and their group nodes
            for (var i = 1; i < groupData.length - 1; i++) {
                if (groupData[i]['Index'] !== groupData[i + 1]['parentIndex'] && groupData[i]['Level'] > 1) {
                    var node = filterDataByField(cmprData, groupData[i]['SignalID'], 'ComparisonSignalID');
                    if (node.length === 0) {
                        var siblings = filterDataByField(groupData, groupData[i]['parentIndex'], 'parentIndex');
                        var groupNodeIndex = groupData[i]['parentIndex'];
                        groupData.splice(i, 1);
                        i = i - 1;
                        if (siblings.length <= 1) {
                            // delete nearest group node and traverse up the table and make deletions of group nodes if needed
                            groupData = deleteParentGroupNodes(groupNodeIndex, groupData);
                        }
                    }
                }
            }
            return groupData;
        }

        function deleteParentGroupNodes (groupNodeIndex, groupData) {
            var groupNode = filterDataByField(groupData, groupNodeIndex, 'Index');
            var position = groupData.indexOf(groupNode[0]);
            var parentIndex = groupNode[0]['parentIndex'];
            groupData.splice(position, 1);
            var siblings = filterDataByField(groupData, parentIndex, 'parentIndex');
            if (siblings.length < 1) groupData = deleteParentGroupNodes(parentIndex, groupData);
            return groupData;
        }

        function adjustIndexes (groupData) {
            for (var i = 0; i < groupData.length; i++) {
                if (i !== localGroupJSON[i]['Index']) {
                    var childNodes = filterDataByField(groupData, groupData[i]['Index'], 'parentIndex');
                    if (childNodes.length !== 0) {
                        childNodes.forEach(node => {
                            node['parentIndex'] = i;
                        });
                    }
                    groupData[i]['Index'] = i;
                }
            }
            return groupData;
        }

        function removeExtraSpaces (cmprBodyRows) {
            // removes any extra spaces present in last after adding all the result icons in a signal column
            cmprBodyRows.forEach(node => {
                var resultNode = node.querySelectorAll('td')[4];
                if (resultNode.lastChild.innerText === undefined) resultNode.lastChild.remove();
            });
        }

        function addBordersForGroupNodes () {
            var currentTable = getCurrentComparisonTable();
            // if sorting is done then rows are re-ordered so removing the borders
            currentTable.forEach(node => {
                node.classList.remove('common-cell-border-bottom');
            });
            for (var index = 0; index < currentTable.length - 1; index++) {
                if (isGroupNode(currentTable[index])) currentTable[index].classList.add('common-cell-border-bottom');
                else {
                    if (isGroupNode(currentTable[index + 1])) currentTable[index].classList.add('common-cell-border-bottom');
                }
            }
        }

        function calculateResultCategoryCount (cmprData, resultStatusMatched, resultStatusMismatched, resultStatusNotCompared) {
            var categoryCount = { 'matched': 0, 'mismatched': 0, 'notCompared': 0 };
            cmprData.forEach(node => {
                if (resultStatusMatched.includes(node['Result'])) categoryCount['matched']++;
                else if (resultStatusMismatched.includes(node['Result'])) categoryCount['mismatched']++;
                else categoryCount['notCompared']++; // at top level only 3 main categories for result icon
            });
            return categoryCount;
        }

        function getNumberOfSpaces (result, categoryCount, resultStatusMatched, resultStatusMismatched, resultStatusNotCompared) {
            var resultSpaces = { spaceCount: 0, numberOfDigits: 0 };
            if (resultStatusMatched.includes(result)) return resultSpaces;
            else if (resultStatusMismatched.includes(result)) {
                if (categoryCount['matched'] > 0) resultSpaces = updateResultSpaces(resultSpaces, categoryCount["matched"]);
                return resultSpaces;
            } else { // all the others fall into not compared category
                if (categoryCount['matched'] > 0) resultSpaces = updateResultSpaces(resultSpaces, categoryCount["matched"]);
                if (categoryCount['mismatched'] > 0) resultSpaces = updateResultSpaces(resultSpaces, categoryCount["mismatched"]);
                return resultSpaces;
            }
        }

        function updateResultSpaces (resultSpaces, number) {
            resultSpaces['spaceCount'] += 6;
            resultSpaces["numberOfDigits"] += (Math.log(number) * Math.LOG10E + 1 | 0);
            resultSpaces["numberOfDigits"] += 2;
            return resultSpaces;
        }

        function isGroupNode (node) {
            if (node.querySelectorAll('td')[0].firstElementChild.childElementCount !== 0) return true;
            else return false;
        }

        function fillResultsForGroupNodes (rowsData, rowIndex, categoryCount) {
            var resultCount = {
                'matched': 0,
                'mismatched': 0,
                'unaligned': 0
            };
            var children = filterDataByField(rowsData, rowIndex, 'parentIndex');
            for (let i = 0; i < children.length; i++) {
                if (children[i]['Result'] === undefined) {
                    fillResultsForGroupNodes(rowsData, children[i]['Index'], categoryCount);
                    categorisedNodeResult = children[i]['Result'];
                } else  categorisedNodeResult = calculateResultCount(children[i]['Result']);
                resultCount = updateResultCount(resultCount, categorisedNodeResult);
            }
            var row = filterDataByField(rowsData, rowIndex, 'Index')[0]
            var node = row['node'];
            row['Result'] = resultCount;
            var resultCell = Array.from(node.querySelectorAll('td'))[4];
            // displaying the corresponding result status icons for the group node
            if (resultCount.matched !== 0) resultCell.innerHTML += comparePassStr + '&nbsp;<span>' + resultCount.matched + '</span>&nbsp;&nbsp';
            else {
                if (categoryCount['matched'] > 0) appendSpaces(resultCell, categoryCount['matched']);
            }
            if (resultCount.mismatched !== 0) resultCell.innerHTML += compareFailStr + '&nbsp;<span>' + resultCount.mismatched + '</span>&nbsp;&nbsp;';
            else {
                if (categoryCount['mismatched'] > 0) appendSpaces(resultCell, categoryCount['mismatched']);
            }
            if (resultCount.unaligned !== 0) resultCell.innerHTML += compareNotComparedStr + '&nbsp;<span>' + resultCount.unaligned + '</span>&nbsp;&nbsp';
        }

        function appendSpaces (resultCell, resultNumber) {
            var resultSpaces = { spaceCount: 0, numberOfDigits: 0 };
            resultSpaces = updateResultSpaces(resultSpaces, resultNumber);
            resultCell.innerHTML += '&nbsp'.repeat(resultSpaces['spaceCount'] + resultSpaces['numberOfDigits']);
        }

        function updateResultCount (resultCount, nodeResult) {
            if (nodeResult.matched > 0) resultCount.matched += nodeResult.matched;
            if (nodeResult.mismatched > 0) resultCount.mismatched += nodeResult.mismatched;
            if (nodeResult.unaligned > 0) resultCount.unaligned += nodeResult.unaligned;
            return resultCount;
        }

        function calculateResultCount (signalResult) {
            var matchedCategory = [metaData.MatchedTip, metaData.EmptyTip];
            var mismatchedCategory = [metaData.UnmatchedTip, metaData.DatatypeMismatchTip, metaData.TimeMismatchTip, metaData.StartStopMismatchTip, metaData.UnitsMismatchTip];
            var notComparedCategory = [metaData.UnalignedTip, metaData.UnmatchedEmptySyncedTip, metaData.UnsupportedTip, metaData.CanceledTip];
            var nodeResult = {
                'matched': 0,
                'mismatched': 0,
                'unaligned': 0
            };
            // since this is the result object for a signal node it will have only one type in it
            var value = Object.keys(signalResult)[0];
            if (matchedCategory.includes(value)) nodeResult.matched += signalResult[value];
            else if (mismatchedCategory.includes(value)) nodeResult.mismatched += signalResult[value];
            else nodeResult.unaligned += signalResult[value];
            return nodeResult;
        }

        function filterDataByField (sourceData, value, fieldName) {
            var result = sourceData.filter(obj => {
                return obj[fieldName] === value;
            });
            return result;
        }

        function performGrouping (event) {
            var groupRow = event.target.closest('tr');
            var groupRowInfo = filterDataByField(localGroupJSON, groupRow, 'node');
            var groupNode = groupRow.querySelectorAll('span')[1].firstElementChild;
            var expand = false;
            // expanding or collapsing the group node
            if (groupNode.classList.contains('group-right-arrow')) {
                groupNode.classList.replace('group-right-arrow', 'group-down-arrow');
                expand = true;
            } else {
                groupNode.classList.replace('group-down-arrow', 'group-right-arrow');
            }
            var children = filterDataByField(localGroupJSON, groupRowInfo[0]['Index'], 'parentIndex');
            for (var i = 0; i < children.length; i++) {
                if (expand) children[i]['node'].classList.remove('row-display-off')
                else collapseRows(children[i], localGroupJSON);
            }
        }

        function collapseRows (currentRow, localGroupJSON) {
            currentRow['node'].classList.add('row-display-off');
            var children = filterDataByField(localGroupJSON, currentRow['Index'], 'parentIndex');
            if (children.length !== 0) {
                var groupNode = currentRow['node'].querySelectorAll('span')[1].firstElementChild;
                if (groupNode.classList.contains('group-down-arrow')) {
                    groupNode.classList.replace('group-down-arrow', 'group-right-arrow');
                }
                for (var i = 0; i < children.length; i++) {
                    collapseRows(children[i], localGroupJSON);
                }
            }
        }

        function fillSummary (cmprData) {
            const summaryHead = document.querySelector('#printable .summary-label');
            const tableHead = document.querySelector('#printable .cmpr-tbl-hdr-content');
            const tableBody = document.querySelector('#printable .cmpr-tbl-bdy-content');
            const colHeaders = metaData.ColumnHeaders;
            const colNames = metaData.ColumnNames;

            summaryHead.innerHTML = metaData.SummaryLabel;

            let th, tr, td;
            const colDispNum = 5;
            tr = document.createElement('tr');
            tr.setAttribute('class', 'rowComparisonsHead');
            for (let colIndex = 0; colIndex < colDispNum; colIndex++) {
                th = document.createElement('th');
                th.setAttribute('class', 'print-summary-hdr common-cell signal-cell unselectable');
                tr.appendChild(th);
                th.innerHTML = colHeaders[colIndex];
            }
            tableHead.appendChild(tr);

            cmprData.forEach(function (row, index) {
                tr = document.createElement('tr');
                tr.setAttribute('class', 'cmpr-row');
                if (!isGroupingEnabled && !isSortingEnabled) {
                    if (isValidDataSet(cmprData)) {
                        tr.addEventListener('click', rowClickDisplay.bind(tr, index));
                    }
                }
                for (let colIndex = 0; colIndex < colDispNum; colIndex++) {
                    td = document.createElement('td');
                    tr.appendChild(td);
                    let name = colNames[colIndex];
                    if (isValidDataSet(cmprData)) {
                        switch (name) {
                            case "MaxDifference":
                                td.setAttribute('class', 'print-summary-bdy common-cell signal-cell unselectable');
                                td.innerHTML = parseFloat(row[name]).toFixed(2);
                                break;
                            case "Result":
                                td.setAttribute('class', 'print-summary-bdy common-cell signal-cell unselectable');
                                if (row[name] === "WithinTolerance") {
                                    td.innerHTML = comparePassStr;
                                } else if (row[name] === "Empty") {
                                    td.innerHTML = comparePassEmptyStr;
                                } else if (row[name] === "Unaligned") {
                                    td.innerHTML = compareUnalignedStr;
                                } else if (row[name] === "Canceled") {
                                    td.innerHTML = compareCanceledStr;
                                } else if (row[name] === "EmptySynced") {
                                    td.innerHTML = notComparedEmptySyncedStr;
                                } else if (row[name] === "Unsupported") {
                                    td.innerHTML = notComparedUnsupportedStr;
                                } else if (row[name] === "DataTypeMismatch") {
                                    td.innerHTML = compareFailDatatypeStr;
                                } else if (row[name] === "TimeMismatch") {
                                    td.innerHTML = compareFailTimeStr;
                                } else if (row[name] === "StartStopMismatch") {
                                    td.innerHTML = compareFailStartStopStr;
                                } else if (row[name] === "UnitsMismatch") {
                                    td.innerHTML = compareFailUnitsStr;
                                } else {
                                    td.innerHTML = compareFailStr;
                                }
                                break;
                            case 'SignalName':
                                td.setAttribute('class', 'print-summary-bdy common-cell signal-cell unselectable');
                                td.textContent = row[name];
                                break;
                            default:
                                td.setAttribute('class', 'print-summary-bdy common-cell signal-cell unselectable');
                                td.innerHTML = row[name];
                        }
                    } else {
                        td.setAttribute('class', 'print-summary-bdy common-cell  signal-cell unselectable');
                        td.innerHTML = row[name];
                    }
                }
                tableBody.appendChild(tr);
            });
        }

        function rowClickDisplay (signalInd, signalIndexFromShortcut) {
            if (isGroupingEnabled && localGroupJSON.length !== 0) {
                // the signalInd is used to check if there are any corresponding entries in localJSON data. The presence of entries indiactes that it is not a group node and a corresponding plot has to be displayed
                var node = filterDataByField(localGroupJSON, signalInd + 1, 'Index');
                let highlightedSignalID = node[0]['SignalID'];
                if (metaData.RowsToReport === 'ReportOnlyMismatchedSignals') {
                    for (var i = 0; i < localJSON.length; i++) {
                        localJSON[i]['Index'] = i + 1;
                    }
                }
                var childNode = filterDataByField(localJSON, highlightedSignalID, 'ComparisonSignalID');
                if (event.currentTarget.rowIndex === undefined) {
                    if (signalIndexFromShortcut === undefined) {
                        highlightRow(signalInd);
                        currentSignal = signalInd;
                    } else {
                        highlightRow(signalIndexFromShortcut);
                        currentSignal = signalInd;
                    }
                } else {
                    highlightRow(event.currentTarget.rowIndex);
                    currentSignal = event.currentTarget.rowIndex;
                }
                if (childNode.length !== 0) {
                    signalInd = childNode[0]['Index'] - 1;
                } else {
                    signalInd = -1;
                }
                dispImage(signalInd, 'interactive', 'visuals', '', document);
                fillPropertiesTable(signalInd);
            } else {
                currentSignal = signalInd;
                dispImage(signalInd, 'interactive', 'visuals', '', document);
                fillPropertiesTable(signalInd);
                if (event.currentTarget.rowIndex === undefined) {
                    highlightRow(signalIndexFromShortcut);
                } else {
                    highlightRow(event.currentTarget.rowIndex);
                }
            }
        }

        function highlightRow (signalInd) {
            let groupNodeBorder = false;
            currentSignal = signalInd;
            const tableBody = document.querySelector('#interactive .cmpr-tbl-bdy-content');
            let curRow = tableBody.rows[signalInd];
            let prevRow = tableBody.rows[defaultSignal];
            if (prevRow === undefined) prevRow = tableBody.querySelectorAll('tr.cmpr-row-selected')[0];
            if (curRow.classList.contains('common-cell-border-bottom')) {
                curRow.setAttribute('class', 'cmpr-row-selected cmpr-grid common-cell-border-bottom');
            } else {
                curRow.setAttribute('class', 'cmpr-row-selected cmpr-grid signal-cell');
            }
            if (isGroupingEnabled) {
                if (prevRow !== curRow) {
                    // if any child nodes are collapsed then they have to be collapsed even when the highlighting is removed from them i.e a different signal is clicked in the table
                    if (prevRow.classList.contains('row-display-off')) {
                        if (prevRow.classList.contains('common-cell-border-bottom')) prevRow.setAttribute('class', 'cmpr-row cmpr-grid row-display-off common-cell-border-bottom');
                        else prevRow.setAttribute('class', 'cmpr-row cmpr-grid row-display-off');
                    } else {
                        if (prevRow.classList.contains('common-cell-border-bottom')) prevRow.setAttribute('class', 'cmpr-row cmpr-grid common-cell-border-bottom');
                        else prevRow.setAttribute('class', 'cmpr-row cmpr-grid');
                    }
                    defaultSignal = signalInd;
                    prevRow.childNodes.forEach(col => {
                        if (col.classList.contains('common-cell-border')) {
                            col.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell  common-cell-border unselectable ');
                        } else {
                            col.setAttribute('class', 'cmpr-cell-bdy common-cell unselectable ');
                        }
                    });
                    if (isGroupNode(prevRow)) prevRow.childNodes[0].firstElementChild.classList.add('groupCell');
                }
            } else {
                if (prevRow !== curRow) {
                    prevRow.setAttribute('class', 'cmpr-row cmpr-grid');
                    defaultSignal = signalInd;
                    prevRow.childNodes.forEach(col => {
                        if (col.classList.contains('common-cell-border')) {
                            col.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable ');
                        } else {
                            col.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell unselectable ');
                        }
                    });
                }
            }
            curRow.childNodes.forEach(col => {
                if (col.classList.contains('common-cell-border')) {
                    col.setAttribute('class', 'cmpr-cell-bdy common-cell signal-cell common-cell-border unselectable ');
                } else {
                    col.setAttribute('class', 'cmpr-cell-bdy common-cell unselectable ');
                }
            });
            if (isGroupNode(curRow)) curRow.childNodes[0].firstElementChild.classList.add('groupCell');
        }

        function makePropertiesTable () {
            const tableTitle = document.querySelector('#interactive .prop-title');
            const tableBody = document.querySelector('#interactive .prop-tbl-bdy-content');
            const tableHead = document.querySelector('#interactive .prop-tbl-hdr-content');
            const colHeaders = ['', metaData.BaselineLabel, metaData.CompareToLabel];

            let tr = document.createElement('tr');
            tr.className = 'prop-row prop-grid';

            let th0 = document.createElement('th');
            th0.className = 'prop-cell-hdr-blnk prop-hdr-col common-cell-border';
            tr.appendChild(th0);
            th0.innerHTML = colHeaders[0].concat('<span class="prop-resize-handle"></span>');

            let th1 = document.createElement('th');
            th1.className = 'prop-cell-hdr-hrz prop-hdr-col common-cell-border';
            tr.appendChild(th1);
            th1.innerHTML = colHeaders[1].concat('<span class="prop-resize-handle"></span>');

            let th2 = document.createElement('th');
            th2.className = 'prop-cell-hdr-hrz prop-hdr-col common-cell-border';
            tr.appendChild(th2);
            th2.innerHTML = colHeaders[2];

            tableTitle.innerHTML = metaData.PropertiesLabel;
            tableHead.appendChild(tr);

            let numCols = 3;
            for (let rowIndex = 0; rowIndex < propertyNames.length; rowIndex++) {
                tr = document.createElement('tr');
                for (let colIndex = 0; colIndex < numCols; colIndex++) {
                    let td = document.createElement('td');
                    tr.appendChild(td);
                    if (colIndex === 0) {
                        td.innerHTML = propertyNames[rowIndex];
                        td.id = propertyIds[rowIndex];
                        td.setAttribute('class', 'prop-cell-hdr-vrt  signal-cell common-cell-border');
                    } else {
                        td.setAttribute('class', 'prop-cell common-cell signal-cell common-cell-border');
                        let cellIdStr = propertyVars[rowIndex] + colIndex;
                        if (cellIdStr === "LineColor1") {
                            let strVal = '<div class="line-base"><\div>';
                            td.innerHTML = strVal;
                        } else if (cellIdStr === "LineColor2") {
                            let strVal = '<div class="line-cmpr"><\div>';
                            td.innerHTML = strVal;
                        } else {
                            td.innerHTML = '';
                        }
                    }
                }
                tr.setAttribute('class', 'divTableRow prop-grid');
                tableBody.appendChild(tr);
            }
        }

        function makeCombinedTable (doc) {
            const tableTitle = document.querySelector('#printable .prop-title');
            const tableBody = doc.querySelector('.prop-tbl-bdy-content');
            const tableHead = doc.querySelector('.prop-tbl-hdr-content');
            const colHeaders = ['', metaData.BaselineLabel, metaData.CompareToLabel];

            let tr = document.createElement('tr');
            tr.className = 'prop-row';

            let th0 = document.createElement('th');
            th0.className = 'sig-prop-cell-hdr-blnk';
            tr.appendChild(th0);
            th0.innerHTML = colHeaders[0];

            let th1 = document.createElement('th');
            th1.className = 'sig-prop-cell-hdr-hrz';
            tr.appendChild(th1);
            th1.innerHTML = colHeaders[1];

            let th2 = document.createElement('th');
            th2.className = 'sig-prop-cell-hdr-hrz';
            tr.appendChild(th2);
            th2.innerHTML = colHeaders[2];

            tableHead.appendChild(tr);
            let numCols = 3;
            for (let rowIndex = 0; rowIndex < combinedNames.length; rowIndex++) {
                tr = document.createElement('tr');
                for (let colIndex = 0; colIndex < numCols; colIndex++) {
                    let td = document.createElement('td');
                    tr.appendChild(td);
                    if (colIndex === 0) {
                        td.innerHTML = combinedNames[rowIndex];
                        td.id = combinedIds[rowIndex];
                        td.setAttribute('class', 'sig-prop-cell-hdr-vrt common-cell signal-cell common-cell-border');
                    } else {
                        td.setAttribute('class', 'sig-prop-cell common-cell signal-cell common-cell-border');
                        let cellIdStr = combinedVars[rowIndex] + colIndex;
                        if (cellIdStr === "LineColor1") {
                            let strVal = '<div class="line-base"><\div>';
                            td.innerHTML = strVal;
                        } else if (cellIdStr === "LineColor2") {
                            let strVal = '<div class="line-cmpr"><\div>';
                            td.innerHTML = strVal;
                        } else {
                            td.innerHTML = '';
                        }
                    }
                }
                tr.setAttribute('class', 'divTableRow');
                tableBody.appendChild(tr);
            }
        }

        function fillPropertiesTable (signalInd) {
            const colNames = metaData.ColumnNames;
            let propTable = document.querySelector('.prop-tbl-bdy-content');
            // the properties table is empty when clicked on a group node
            if (signalInd === -1) {
                propTable.classList.add('row-display-off');
            } else {
                if (propTable.classList.contains('row-display-off')) {
                    propTable.classList.remove('row-display-off');
                }
                for (let rowIndex = 0; rowIndex < propertyVars.length; rowIndex++) {
                    let rowIndexOffset = rowIndex + 1;
                    let cellIdStr = propertyVars[rowIndex];
                    let myCell = document.querySelectorAll("#interactive .properties tbody tr:nth-child(" + rowIndexOffset + ") td[class^='prop-cell']");
                    let myRow = document.querySelectorAll("#interactive .properties tbody tr:nth-child(" + rowIndexOffset + ")");
                    const cellIdStr1 = cellIdStr + 1;
                    const cellIdStr2 = cellIdStr + 2;
                    const cellData1 = localJSON[signalInd][cellIdStr1];
                    const cellData2 = localJSON[signalInd][cellIdStr2];

                    switch (myCell[0].id) {
                        case 'Name':
                            myCell[1].textContent = cellData1;
                            myCell[2].textContent = cellData2;
                            if (cellData1 === cellData2) {
                                myCell[0].className = 'prop-cell-hdr-vrt common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[1].className = 'prop-cell common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[2].className = 'prop-cell common-cell signal-cell common-cell-border prop-resize-col';
                            } else {
                                myCell[0].className = 'prop-cell-hdr-vrt-diff common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[1].className = 'prop-cell-diff common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[2].className = 'prop-cell-diff common-cell signal-cell common-cell-border prop-resize-col';
                            }
                            break;
                        case "Line":
                            // all other property fields have this class being added in them in this function
                            myCell[0].classList.add('common-cell');
                            const rgbPct1 = "rgb(" +
                                ((cellData1[0] * 100).toFixed(2)) + '%, ' +
                                ((cellData1[1] * 100).toFixed(2)) + '%, ' +
                                ((cellData1[2] * 100).toFixed(2)) + '%)';
                            const lineStyle1 = getLineStyle(localJSON[signalInd].LineDashed1);
                            document.getElementsByClassName("line-base")[0].style =
                                'border-color: ' + rgbPct1 + ';' + 'border-style: ' + lineStyle1 + ';' + 'background-color:' + rgbPct1 + ';';
                            const rgbPct2 = "rgb(" +
                                ((cellData2[0] * 100).toFixed(2)) + '%, ' +
                                ((cellData2[1] * 100).toFixed(2)) + '%, ' +
                                ((cellData2[2] * 100).toFixed(2)) + '%)';
                            const lineStyle2 = getLineStyle(localJSON[signalInd].LineDashed2);
                            document.getElementsByClassName("line-cmpr")[0].style =
                                'border-color: ' + rgbPct2 + ';' + 'border-style: ' + lineStyle2 + ';' + 'background-color:' + rgbPct2 + ';';
                            break;
                        case "Channel":
                            myCell[1].innerHTML = cellData1;
                            myCell[2].innerHTML = cellData2;
                            if (arrayCompare(cellData1, cellData2)) {
                                myCell[0].className = 'prop-cell-hdr-vrt common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[1].className = 'prop-cell common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[2].className = 'prop-cell common-cell signal-cell common-cell-border prop-resize-col';
                            } else {
                                myCell[0].className = 'prop-cell-hdr-vrt-diff common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[1].className = 'prop-cell-diff common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[2].className = 'prop-cell-diff common-cell signal-cell common-cell-border prop-resize-col';
                            }
                            break;
                        default:
                            myCell[1].innerHTML = cellData1;
                            myCell[2].innerHTML = cellData2;
                            if (cellData1 === cellData2) {
                                myCell[0].className = 'prop-cell-hdr-vrt common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[1].className = 'prop-cell common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[2].className = 'prop-cell common-cell signal-cell common-cell-border prop-resize-col';
                            } else {
                                myCell[0].className = 'prop-cell-hdr-vrt-diff common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[1].className = 'prop-cell-diff common-cell signal-cell common-cell-border prop-resize-col';
                                myCell[2].className = 'prop-cell-diff common-cell signal-cell common-cell-border prop-resize-col';
                            }
                    }
                    if (myCell[0].id !== "Name" && myCell[0].id !== "Block Path") {
                        myRow[0].style.display = (localJSON[signalInd].Result === "Unaligned" || localJSON[signalInd].Result === "Canceled") ? 'none' : '';
                    }
                }
            }
        }

        function fillCombinedRow() {
            let resultsRows = document.querySelectorAll("#printable .results-row");
            for (let rowIndex = 0; rowIndex < resultsRows.length; rowIndex++) {
                let resultsRow = resultsRows[rowIndex];
                makeCombinedTable(resultsRow);
                fillCombinedTable(rowIndex, resultsRow);
                dispImage(rowIndex, 'printable', 'print-visuals', 'print-', resultsRow);
            }
        }

        function fillCombinedTable(signalInd, doc) {
            const resultsHead = doc.querySelector('#printable .results-label');
            if (signalInd < localJSON.length) {
                for (let rowIndex = 0; rowIndex < combinedVars.length; rowIndex++) {
                    let rowIndexOffset = rowIndex + 1;
                    let cellIdStr = combinedVars[rowIndex];
                    let myCell = doc.querySelectorAll("tbody tr:nth-child(" + rowIndexOffset + ") td[class^='sig-prop-cell']");
                    let myRow = doc.querySelectorAll("tbody tr:nth-child(" + rowIndexOffset + ")");
                    let cellIdStr1 = cellIdStr + 1;
                    let cellIdStr2 = cellIdStr + 2;
                    let cellData1 = localJSON[signalInd][cellIdStr1];
                    let cellData2 = localJSON[signalInd][cellIdStr2];

                    resultsHead.innerHTML = localJSON[signalInd]["SignalName1"];
                    switch (myCell[0].id) {
                        case 'Name':
                            myCell[1].textContent = cellData1;
                            myCell[2].textContent = cellData2;
                            if (cellData1 === cellData2) {
                                myCell[0].className = 'sig-prop-cell-hdr-vrt common-cell signal-cell common-cell-border';
                                myCell[1].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                                myCell[2].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            } else {
                                myCell[0].className = 'sig-prop-cell-hdr-vrt-diff common-cell signal-cell common-cell-border';
                                myCell[1].className = 'sig-prop-cell-diff common-cell signal-cell common-cell-border';
                                myCell[2].className = 'sig-prop-cell-diff common-cell signal-cell common-cell-border';
                            }
                            break;
                        case "Line":
                            const rgbPct1 = "rgb(" +
                                ((cellData1[0] * 100).toFixed(2)) + '%, ' +
                                ((cellData1[1] * 100).toFixed(2)) + '%, ' +
                                ((cellData1[2] * 100).toFixed(2)) + '%)';
                            const lineStyle1 = getLineStyle(localJSON[signalInd].LineDashed1);
                            doc.getElementsByClassName("line-base")[0].style =
                                'border-color: ' + rgbPct1 + ';' + 'border-style: ' + lineStyle1 + ';' + 'background-color:' + rgbPct1 + ';';
                            const rgbPct2 = "rgb(" +
                                ((cellData2[0] * 100).toFixed(2)) + '%, ' +
                                ((cellData2[1] * 100).toFixed(2)) + '%, ' +
                                ((cellData2[2] * 100).toFixed(2)) + '%)';
                            const lineStyle2 = getLineStyle(localJSON[signalInd].LineDashed2);
                            doc.getElementsByClassName("line-cmpr")[0].style =
                                'border-color: ' + rgbPct2 + ';' + 'border-style: ' + lineStyle2 + ';' + 'background-color:' + rgbPct2 + ';';
                            break;
                        case "Channel":
                            myCell[1].innerHTML = cellData1;
                            myCell[2].innerHTML = cellData2;
                            if (arrayCompare(cellData1, cellData2)) {
                                myCell[0].className = 'sig-prop-cell-hdr-vrt common-cell signal-cell common-cell-border';
                                myCell[1].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                                myCell[2].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            } else {
                                myCell[0].className = 'sig-prop-cell-hdr-vrt-diff common-cell signal-cell common-cell-border';
                                myCell[1].className = 'sig-prop-cell-diff common-cell signal-cell common-cell-border';
                                myCell[2].className = 'sig-prop-cell-diff common-cell signal-cell common-cell-border';
                            }
                            break;
                        case "Max Diff":
                            cellData1 = localJSON[signalInd][cellIdStr];
                            if (cellData1 === undefined || cellData1 === null) {
                                myCell[1].innerHTML = 'N/A';
                            } else {
                                myCell[1].innerHTML = cellData1.toFixed(3);
                            }
                            myCell[2].innerHTML = "--";
                            myCell[0].className = 'sig-prop-cell-hdr-vrt common-cell signal-cell common-cell-border';
                            myCell[1].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            myCell[2].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            break;
                        case "Result":
                            cellData1 = localJSON[signalInd][cellIdStr];
                            if (cellData1 === "WithinTolerance") {
                                myCell[1].innerHTML = comparePassStr;
                            } else if (cellData1 === "Empty") {
                                myCell[1].innerHTML = comparePassEmptyStr;
                            } else if (cellData1 === "Unaligned") {
                                myCell[1].innerHTML = compareUnalignedStr;
                            } else if (cellData1 === "Canceled") {
                                myCell[1].innerHTML = compareCanceledStr;
                            } else if (cellData1 === "EmptySynced") {
                                myCell[1].innerHTML = notComparedEmptySyncedStr;
                            } else if (cellData1 === "Unsupported") {
                                myCell[1].innerHTML = notComparedUnsupportedStr;
                            } else if (cellData1 === "DataTypeMismatch") {
                                myCell[1].innerHTML = compareFailDatatypeStr;
                            } else if (cellData1 === "TimeMismatch") {
                                myCell[1].innerHTML = compareFailTimeStr;
                            } else if (cellData1 === "StartStopMismatch") {
                                myCell[1].innerHTML = compareFailStartStopStr;
                            } else if (cellData1 === "UnitsMismatch") {
                                myCell[1].innerHTML = compareFailUnitsStr;
                            } else {
                                myCell[1].innerHTML = compareFailStr;
                            }
                            myCell[2].innerHTML = "--";
                            myCell[0].className = 'sig-prop-cell-hdr-vrt common-cell signal-cell common-cell-border';
                            myCell[1].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            myCell[2].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            break;
                        default:
                            myCell[1].innerHTML = cellData1;
                            myCell[2].innerHTML = cellData2;
                            if (cellData1 === cellData2) {
                                myCell[0].className = 'sig-prop-cell-hdr-vrt common-cell signal-cell common-cell-border';
                                myCell[1].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                                myCell[2].className = 'sig-prop-cell common-cell signal-cell common-cell-border';
                            } else {
                                myCell[0].className = 'sig-prop-cell-hdr-vrt-diff common-cell signal-cell common-cell-border';
                                myCell[1].className = 'sig-prop-cell-diff common-cell signal-cell common-cell-border';
                                myCell[2].className = 'sig-prop-cell-diff common-cell signal-cell common-cell-border';
                            }
                    }

                    if (myCell[0].id !== "Name" && myCell[0].id !== "Block Path" &&
                        myCell[0].id !== "Result") {
                        if (myCell[0].id !== "Max Diff") {
                            myRow[0].style.display = (localJSON[signalInd].Result === "Unaligned" || localJSON[signalInd].Result === "Canceled") ? 'none' : '';
                        } else {
                            myRow[0].style.display = (localJSON[signalInd].Result === "Canceled") ? 'none' : '';
                        }
                    }
                }
            }
        }

        function createResultTable () {
            var resultTable = document.createElement('table');
            resultTable.classList.add('resultTable');
            return resultTable;
        }

        function createHeading () {
            var theading = document.createElement('tr');
            theading.classList.add('resultTableHeading');
            var th1 = document.createElement('th');
            th1.classList.add('cmpr-cell-hdr', 'resultTable');
            var headingSpan = document.createElement('span');
            headingSpan.classList.add('headingSpan');
            headingSpan.innerText = "Run";
            th1.appendChild(headingSpan);
            var th2 = document.createElement('th');
            th2.classList.add('cmpr-cell-hdr', 'resultTable');
            var headingSpan = document.createElement('span');
            headingSpan.classList.add('headingSpan');
            headingSpan.innerText = "Name";
            th2.appendChild(headingSpan);
            theading.appendChild(th1);
            theading.appendChild(th2);
            return theading;
        }

        function createDefaultRows (signalData) {
            var tRow1 = document.createElement('tr');
            var tdRun1 = document.createElement('td');
            tdRun1.classList.add('prop-cell-hdr-vrt', 'resultTable');
            tdRun1.innerText = signalData['Run1'];
            var tdName1 = document.createElement('td');
            tdName1.classList.add('prop-cell-hdr-vrt', 'resultTable');
            tdName1.innerText = signalData['SignalName'];
            tRow1.appendChild(tdRun1);
            tRow1.appendChild(tdName1);

            var tRow2 = document.createElement('tr');
            var tdRun2 = document.createElement('td');
            tdRun2.classList.add('prop-cell-hdr-vrt', 'resultTable');
            tdRun2.innerText = signalData['CompareToRunName'];
            var tdName2 = document.createElement('td');
            tdName2.classList.add('prop-cell-hdr-vrt', 'resultTable');
            tdName2.innerText = signalData['SignalName'];
            tRow2.appendChild(tdRun2);
            tRow2.appendChild(tdName2);

            var rows = { 'row1': tRow1, 'row2': tRow2 };
            return rows;
        }

        function constructResultSpecificHeadings (theading, headingNames) {
            var th1 = document.createElement('th');
            th1.classList.add('cmpr-cell-hdr', 'resultTable');
            var headingSpan = document.createElement('span');
            headingSpan.classList.add('headingSpan');
            headingSpan.innerText = headingNames[0];
            th1.appendChild(headingSpan);
            theading.appendChild(th1);
            // start-stop time mismatch signals have extra 2 columns in the result table:'Start Time', 'Stop Time'
            // so here we check if the input array has the required element and then add the corresponding heading
            if (headingNames[1]) {
                var th2 = document.createElement('th');
                th2.classList.add('cmpr-cell-hdr', 'resultTable');
                var headingSpan = document.createElement('span');
                headingSpan.classList.add('headingSpan');
                headingSpan.innerText = headingNames[1];
                th2.appendChild(headingSpan);
                theading.appendChild(th2);
            }
        }

        function fillResultSpecificColumns (rows, resultData) {
            // data is filled column wise here
            var tdRun1 = document.createElement('td');
            tdRun1.classList.add('prop-cell-hdr-vrt', 'resultTable');
            tdRun1.innerText = resultData[0];
            rows['row1'].appendChild(tdRun1);
            // the 'resultData' can have either 2 or 4 elements depending on type of signal
            // so here we fill columns only when required element is present
            if (resultData[2]) {
                var tdName1 = document.createElement('td');
                tdName1.classList.add('prop-cell-hdr-vrt', 'resultTable');
                tdName1.innerText = resultData[2];
                rows['row1'].appendChild(tdName1);
            }

            var tdRun2 = document.createElement('td');
            tdRun2.classList.add('prop-cell-hdr-vrt', 'resultTable');
            tdRun2.innerText = resultData[1];
            rows['row2'].appendChild(tdRun2);
            if (resultData[3]) {
                var tdName2 = document.createElement('td');
                tdName2.classList.add('prop-cell-hdr-vrt', 'resultTable');
                tdName2.innerText = resultData[3];
                rows['row2'].appendChild(tdName2);
            }
        }

        function updateResults (imageBody, items) {
            while (imageBody.firstChild) {
                imageBody.removeChild(imageBody.firstChild);
            }
            items.forEach(function (resultItem) {
                imageBody.appendChild(resultItem);
            });
        }

        function dispImage (imgVal, viewCntnr, trgtCntnr, pref, doc) {
            const imageBody = doc.querySelector('#' + viewCntnr + ' .' + trgtCntnr);
            const image = new Image();
            if (imgVal >= 0) {
                var signalData = localJSON[imgVal];
                // for the result specific status message that has to be displayed in the plot area
                var resultStatus = document.createElement('div');
                resultStatus.classList.add('resultStatus');
                var obj = getMetaData();
                // for the result specific table displayed after status message in the plot area
                var resultTable = createResultTable();
                var theading = createHeading();
                var rows = createDefaultRows(signalData);

                resultTable.appendChild(theading);
                resultTable.appendChild(rows['row1']);
                resultTable.appendChild(rows['row2']);

                switch (signalData.Result) {
                    case 'StartStopMismatch':
                        resultStatus.innerText = obj['StartStopTimesMismatchStatus'];
                        constructResultSpecificHeadings(theading, ['Start Time', 'Stop Time']);
                        var resultData = [signalData['StartTime1'], signalData['StartTime2'], signalData['StopTime1'], signalData['StopTime2']];
                        fillResultSpecificColumns(rows, resultData);
                        updateResults(imageBody, [resultStatus, resultTable]);
                        break;
                    case 'UnitsMismatch':
                        resultStatus.innerText = obj['UnitsMismatchStatus'];
                        constructResultSpecificHeadings(theading, ['Units']);
                        var resultData = [signalData['Units1'], signalData['Units2']];
                        fillResultSpecificColumns(rows, resultData);
                        updateResults(imageBody, [resultStatus, resultTable]);
                        break;
                    case 'DataTypeMismatch':
                        resultStatus.innerText = obj['DatatypesMismatchStatus'];
                        constructResultSpecificHeadings(theading, ['Data type']);
                        var resultData = [signalData['SigDataType1'], signalData['SigDataType2']];
                        fillResultSpecificColumns(rows, resultData);
                        updateResults(imageBody, [resultStatus, resultTable]);
                        break;
                    case 'TimeMismatch':
                        resultStatus.innerText = obj['TimeMismatchStatus'];
                        updateResults(imageBody, [resultStatus, resultTable]);
                        break;
                    case 'EmptySynced':
                        resultStatus.innerText = obj['EmptySyncedStatus'];
                        updateResults(imageBody, [resultStatus, resultTable]);
                        break;
                    case 'Unsupported':
                        resultStatus.innerText = obj['UnsupportedStatus'];
                        updateResults(imageBody, [resultStatus, resultTable]);
                        break;
                    case 'Empty':
                        resultStatus.innerText = obj['EmptySignalsStatus'];
                        updateResults(imageBody, [resultStatus]);
                        break;
                    case 'Unaligned':
                        var unalignedStatusData = {
                            Arg1: signalData['SignalName'],
                            Arg2: signalData['CompareToRunName']
                        };
                        // the signal name and run name have to be substituted dynamically in the unaligned signals status message
                        resultStatus.innerText = obj['UnalignedStatus'].replace(/Arg1|Arg2/gi, function(matched) {
                            return unalignedStatusData[matched];
                        });
                        updateResults(imageBody, [resultStatus]);
                        break;
                    case 'Canceled':
                        resultStatus.innerText = obj['CanceledStatus'];
                        updateResults(imageBody, [resultStatus]);
                        break;
                    default:
                        const imgSelect = getImage(imgVal + 1);
                        if (imgVal < imgSelect.Count) {
                            updateImage(imageBody, image, imgSelect, pref);
                        }
                }
            } else {
                while (imageBody.firstChild) {
                    imageBody.removeChild(imageBody.firstChild);
                }
            }
        }

        function getGroupIcons (imgVal) {
            var image = new Image();
            var imgSelected = getImage(imgVal);
            image.src = imgSelected.Data;
            image.draggable = false;
            return image;
        }

        function updateImage (imageBody, image, imageObject, pref) {
            image.src = imageObject.Data;
            image.id = pref + 'cmpr-plot';
            image.draggable = false;
            while (imageBody.firstChild) {
                imageBody.removeChild(imageBody.firstChild);
            }
            imageBody.appendChild(image);
        }

        function isValidDataSet(cmprData) {
            let validFlag = cmprData[0].Index !== 0;
            return validFlag;
        }

        function getLineStyle(lineSymbol) {
            switch (lineSymbol) {
                case '-':
                    return 'solid';
                case '--':
                    return 'dashed';
                case ':':
                    return 'dotted';
                case '-.':
                    return 'dashed';
                default:
                    return 'solid';
            }
        }

        function arrayCompare(arrayOne, arrayTwo) {
            if (arrayOne.length !== arrayTwo.length) {
                return false;
            }
            for (var i in arrayOne) {
                if (arrayOne[i] instanceof Array && arrayTwo[i] instanceof Array) {
                    if (!arrayCompare(arrayOne[i], arrayTwo[i])) {
                        return false;
                    }
                }
                else if (arrayOne[i] !== arrayTwo[i]) {
                    return false;
                }
            }
            return true;
        }

        function initReportStyle() {
            let reportStyle = document.querySelector("#header .report-style");
            let interactChoice = document.createElement("INPUT");
            let printChoice = document.createElement("INPUT");

            interactChoice.setAttribute("type", "radio");
            interactChoice.setAttribute("name", "styleChoice");
            interactChoice.setAttribute("value", "interactStyle");
            interactChoice.setAttribute("checked", "checked");
            interactChoice.setAttribute("onclick", "interactLevel.style.display = 'grid'; printLevel.style.display = 'none';");

            printChoice.setAttribute("type", "radio");
            printChoice.setAttribute("name", "styleChoice");
            printChoice.setAttribute("value", "printStyle");
            printChoice.setAttribute("onclick", "interactLevel.style.display = 'none'; printLevel.style.display = 'grid';");

            reportStyle.appendChild(interactChoice);
            reportStyle.innerHTML += metaData.InteractiveLabel;
            reportStyle.appendChild(printChoice);
            reportStyle.innerHTML += metaData.PrintableLabel;
        }

        // ------- Window resizing functions -------

        function maintainPaneAspectRatios() {
            setResultsPane();
        }

        function setCursor(cursor) {
            interactLevel.style.cursor = cursor;
        }

        function eastWestSelect() {
            isEastWestActive = true;
            setCursor("ew-resize");
            countDrag = 0;
            event.preventDefault();
        }

        function northSouthSelect() {
            isNorthSouthActive = true;
            setCursor("ns-resize");
            countDrag = 0;
            event.preventDefault();
        }

        function endDrag() {
            isEastWestActive = false;
            isNorthSouthActive = false;
            setCursor("auto");
            countDrag = 0;
        }

        function onDrag() {
            let nsStepRes = 3;
            let ewStepRes = 3;
            if (isNorthSouthActive) {
                countDrag += 1;
                if (countDrag % nsStepRes === 0) {
                    setResultsPane();
                }
            }

            if (isEastWestActive) {
                countDrag += 1;
                if (countDrag % ewStepRes === 0) {
                    setInteractivePane();
                }
            }
            // the 'onDrag()' gets called when the mouse moves anywhere in the '.interactive' div
            // so there are cases this function gets called even when resizing is not initiated, in such cases if 'event.preventDefault' is allowed, then user-select:text does not work when any text in plot area wants to be selected.
            // adding the if condition ensures that 'event.preventDefault' works only when actual resizing is initiated
            if (isNorthSouthActive || isEastWestActive) {
                event.preventDefault();
            }
        }

        function calcResultsPane() {
            let headerHeight = headerLevel.offsetHeight;
            dragbarHeight = horizontalSep.offsetHeight;

            if (isNorthSouthActive || isInitNS) {
                if (isInitNS) {
                    let initSigRatio = .4;
                    signalsHeight = (interactLevel.clientHeight - dragbarHeight) * initSigRatio;
                } else {
                    signalsHeight = event.clientY - headerHeight - interactLevelBorderWidth - dragbarHeight / 2;
                }

                // TODO update to remove hardcoded values based on minimum data div heights
                let limitSigHeight = 117.5;
                if (signalsHeight <= limitSigHeight) {
                    signalsHeight = limitSigHeight;
                }
                propHeight = interactLevel.clientHeight - dragbarHeight - signalsHeight;
                let limitPropHeight = 137.5;
                if (propHeight <= limitPropHeight) {
                    propHeight = limitPropHeight;
                    if (signalsHeight >= (interactLevel.clientHeight - dragbarHeight - propHeight)) {
                        signalsHeight = interactLevel.clientHeight - dragbarHeight - propHeight;
                    }
                }
                isInitNS = 0;
            } else if (typeof signalsHeight === 'undefined') {
                let elemHsep = horizontalSep.getBoundingClientRect();
                signalsHeight = elemHsep.top + 0.5 - headerHeight - interactLevelBorderWidth - dragbarHeight / 2;

                // TODO update to remove hardcoded values based on minimum data div heights
                let limitSigHeight = 117.5;
                if (signalsHeight <= limitSigHeight) {
                    signalsHeight = limitSigHeight;
                }

                propHeight = interactLevel.clientHeight - dragbarHeight - signalsHeight;
                let limitPropHeight = 137.5;  // TODO Tune
                if ((propHeight - limitPropHeight) <= 0) {
                    propHeight = limitPropHeight;
                }
            }
        }

        function setResultsPane() {
            calcResultsPane();

            let sigData = document.querySelector("#interactive .sig-data");
            let propData = document.querySelector("#interactive .prop-data");

            let rows = [
                signalsHeight,
                dragbarHeight,
                propHeight
            ];

            let newRows;
            if ((rows[0] / rows[2]) >= 1) {
                newRows = [
                    (rows[0] / rows[2]).toString() + "fr",
                    rows[1].toString() + "px",
                    "1fr"
                ];
            } else {
                newRows = [
                    "1fr",
                    rows[1].toString() + "px",
                    (rows[2] / rows[0]).toString() + "fr"
                ];
            }

            interactLevel.style.gridTemplateRows = newRows.join(" ");
            event.preventDefault();

            // TODO update to remove hardcoded values
            let sigDataHeightNum;
            let propDataHeightNum;
            if (isNorthSouthActive) {
                sigDataHeightNum = signalsHeight - 19; // header height
                propDataHeightNum = propHeight - 39;   // header + title heights
            } else {
                sigDataHeightNum = (signalsHeight / (signalsHeight + propHeight)) * interactLevel.offsetHeight - 1 - 19;
                propDataHeightNum = (propHeight / (signalsHeight + propHeight)) * interactLevel.offsetHeight - 1 - 39;
            }
            sigData.style.height = sigDataHeightNum.toString() + "px";
            propData.style.height = propDataHeightNum.toString() + "px";
            adjustHeadersAlignment();
        }
        function adjustHeadersAlignment () {
            // the total width of any row in the tables change dynamically depending on whether a scroll bar appears or not on the screen, so the headers width is also correspondingly adjusted to fix the misalignment
            // changing grid columns of headers in properties table
            propDataRow = document.querySelector('.divTableRow.prop-grid');
            propHeaderRow = document.querySelector('.prop-row.prop-grid');
            propHeaderRow.style.gridTemplateColumns = getComputedStyle(propDataRow).gridTemplateColumns;
            // changing grid columns of headers in comparison signals table
            // when only 1 signal present in comparison table, which remains automatically highlighted then it has 'cmpr-row-selected' as the class name
            // to adjust width here we can use any row from the table, so changed the class name in query here to support the case when there is only 1 signal in comparison table
            cmprDataRow = document.querySelector('.cmpr-row-selected.cmpr-grid');
            cmprHeaderRow = document.querySelector('.rowComparisonsHead.cmpr-grid');
            cmprHeaderRow.style.gridTemplateColumns = getComputedStyle(cmprDataRow).gridTemplateColumns;
        }

        function calcInteractivePane() {
            dragbarWidth = verticalSep.offsetWidth;
            signalsWidth = event.clientX - interactLevelBorderWidth - dragbarWidth / 2;
            visualsWidth = interactLevel.clientWidth - dragbarWidth - signalsWidth;
        }

        function setInteractivePane() {
            calcInteractivePane();

            let cols = [
                signalsWidth,
                dragbarWidth,
                visualsWidth
            ];

            let newCols = [
                (cols[0] / cols[2]).toString() + "fr",
                cols[1] + "px",
                "1fr"
            ];

            interactLevel.style.gridTemplateColumns = newCols.join(" ");
            if (cmprRows.length === 0) {
                document.querySelectorAll('.cmpr-grid').forEach(row => {
                    cmprRows.push(row);
                });
            }
            // previously removing the entire style used to remove'display: none' property which is present for certain signalslike Unaligned,
            // now changed it to remove specific property
            cmprRows.forEach(row => {
                row.style.removeProperty('grid-template-columns');
            });

            if (propRows.length === 0) {
                document.querySelectorAll('.prop-grid').forEach(row => {
                    propRows.push(row);
                });
            }
            // each row has a class 'prop-grid' so once this style is removed automatically the 'grid-template-columns' present in class gets applied
            propRows.forEach(row => {
                row.style.removeProperty('grid-template-columns');
            });
            adjustHeadersAlignment();
        }

        function sortColumns (event) {
            // to check for type of sort when clicked on arrows or any part of column headers
            let srcElementClassName = event.srcElement.classList.value;
            if (srcElementClassName === 'arrow sort-des' || srcElementClassName === 'arrow arrow-up' || srcElementClassName === 'arrow arrow-down') {
                asc = false;
            } else if (srcElementClassName.includes('cmpr-cell-hdr')) {
                if (event.srcElement.lastElementChild.classList.value === 'arrow sort-asc') asc = true;
                else asc = false;
            } else if (srcElementClassName === 'cmprHeaderContent') {
                switch (event.srcElement.parentNode.lastChild.classList.value) {
                    case 'unsort': asc = false;
                        break;
                    case 'arrow sort-des': asc = false;
                        break;
                    default: asc = true;
                }
            } else asc = true;

            var columnClicked = event.currentTarget.cellIndex;
            var tables = document.querySelectorAll('.cmpr-tbl-common');
            var table = tables[1];
            const tBody = table.tBodies[0];
            if (isGroupingEnabled) var rows = localGroupJSON.slice(1);
            else var rows = localJSON;
            if (columnClicked === ABS_TOL || columnClicked === REL_TOL || columnClicked === MAX_DIFF) {
                var performSort = verifyEqualValues(rows, columnClicked);
            } else {
                var performSort = true;
            }

            if (performSort) {
                let sortResult = sortWithGrouping(rows, columnClicked, rows);
                window.currentSortedTable = sortResult;
                let sortedRows = [];
                sortResult.forEach(element => {
                    sortedRows.push(element['node']);
                });
                while (tBody.firstChild) {
                    tBody.removeChild(tBody.firstChild);
                }
                tBody.append(...sortedRows);

                // updating this global variable to track which signal is currently highlighted
                defaultSignal = sortedRows.findIndex(row => row.classList.value === 'cmpr-row-selected cmpr-grid');
            }
            var tHead = tables[0].tHead;
            var headerRow = Array.from(tHead.querySelectorAll('th'));

            // if any other column was already sorted before, replace sorted arrows with unsorted arrows
            if (prevSortedColIndex !== -1 && prevSortedColIndex !== columnClicked) {
                headerRow[prevSortedColIndex].removeChild(headerRow[prevSortedColIndex].lastElementChild);
                var unsortDiv = document.createElement('div');
                unsortDiv.className = 'unsort';
                var unsortChild1 = document.createElement('div');
                unsortChild1.className = 'arrow arrow-up';
                var unsortChild2 = document.createElement('div');
                unsortChild2.className = 'arrow arrow-down';
                unsortDiv.appendChild(unsortChild1);
                unsortDiv.appendChild(unsortChild2);
                headerRow[prevSortedColIndex].appendChild(unsortDiv);
            }
            // changing arrows for currently sorted column
            headerRow[columnClicked].removeChild(headerRow[columnClicked].lastElementChild);
            var modifiedDiv = document.createElement('div');
            if (asc === false) {
                modifiedDiv.className = 'arrow sort-asc';
            } else {
                modifiedDiv.className = 'arrow sort-des';
            }
            prevSortedColIndex = columnClicked;
            headerRow[columnClicked].appendChild(modifiedDiv);
            if (isGroupingEnabled) addBordersForGroupNodes();
            event.preventDefault();
        }

        function verifyEqualValues (rows, columnClicked) {
            var name = getColumnName(columnClicked);
            var columnValues = []
            for (var i = 0; i < rows.length; i++) {
                var value = rows[i][name];
                if (value !== undefined) {
                    columnValues.push(parseFloat(value));
                }
            }
            return !(columnValues.every(val => val === columnValues[0]));
        }

        function getColumnName (columnClicked) {
            switch (columnClicked) {
                case ABS_TOL: return "AbsTol1";
                break;
                case REL_TOL: return "RelTol1";
                break;
                case MAX_DIFF: return "MaxDifference";
                break;
            }
        }

        function sortWithGrouping (rows, columnClicked, groupJSON) {
            // collecting nodes which are at same level
            let firstLevelRows = filterDataByField(groupJSON, rows[0]['parentIndex'], 'parentIndex');

            // the above collected first level nodes are sorted in the order according to the column
            if (columnClicked === 0) {
                let sortedRows = firstLevelRows.sort(signalNameSort);
                if (asc) var sortedFirstLevelRows = sortedRows;
                else var sortedFirstLevelRows = sortedRows.reverse();
            } else {
                var sortedFirstLevelRows = firstLevelRows.sort((a, b) => {
                    const RESULT_COLUMN = 4;
                    if (columnClicked === RESULT_COLUMN) {
                        var children = filterDataByField(groupJSON, a['Index'], 'parentIndex');
                        var resultType;
                        // depending on grouping flag different JSON variables were used to construct the comparison table
                        if (isGroupingEnabled) {
                            if (children.length !== 0) aColText = 0;
                            else {
                                // localGroupJSON will have the result stored as Ex: {'mismatch':1}
                                resultType = Object.keys(a['Result'])[0];
                                aColText = getPriority(resultType);
                            }
                        } else {
                            // localJSON will have the result stored as Ex: "WithinTolerance"
                            resultType = a['Result'];
                            aColText = getPriority(resultType);
                        }

                        // since the grouped nodes order has to be maintained so giving them a least value
                        var children = filterDataByField(groupJSON, b['Index'], 'parentIndex');
                        if (isGroupingEnabled) {
                            if (children.length !== 0) bColText = 0;
                            else {
                                resultType = Object.keys(b['Result'])[0];
                                bColText = getPriority(resultType);
                            }
                        } else {
                            resultType = b['Result'];
                            bColText = getPriority(resultType);
                        }
                    } else {
                        var aColText;
                        var bColText;
                        var name = getColumnName(columnClicked);
                        if (a[name] === undefined) aColText = "";
                        else aColText = a[name];
                        if (b[name] === undefined) bColText = "";
                        else bColText = b[name];
                        if (columnClicked === 2) {
                            if (aColText === "") aColText = "0.00%";
                            if (bColText === "") bColText = "0.00%";
                        }
                        if (columnClicked === 1 || columnClicked === 3) {
                            // if any of the text in the 'Max Diff' column is 'N/A' then assigning it a numeric value to sort accordingly
                            if (aColText === 'N/A') aColText = -1;
                            if (bColText === 'N/A') bColText = -1;
                            if (aColText === "") aColText = 0;
                            if (bColText === "") bColText = 0;
                        }
                    }
                    return asc ? parseFloat(aColText) - parseFloat(bColText) : parseFloat(bColText) - parseFloat(aColText);
                });
            }
            // going through the above sorted first level nodes to add the corresponding child nodes in their sorted order
            for (let i = 0; i < sortedFirstLevelRows.length; i++) {
                var children = filterDataByField(groupJSON, sortedFirstLevelRows[i]['Index'], 'parentIndex');
                if (children.length !== 0) {
                    let sortedArray = sortWithGrouping(children, columnClicked, groupJSON);
                    sortedFirstLevelRows.splice(i + 1, 0, ...sortedArray);
                    i = i + sortedArray.length;
                }
            }
            return sortedFirstLevelRows;
        }

        function signalNameSort (a, b) {
            a = a['SignalName'];
            b = b['SignalName'];
            var a1 = a.toLowerCase();
            var b1 = b.toLowerCase();

            if (a1 < b1) return -1;
            if (a1 > b1) return 1;
            return 0;
        }

        // determines the sorting order for different result statuses
        function getPriority (tooltipName) {
            // if grouping flag is OFF then original 'localJSON' is used which have its results stored as strings so including those in cases below. Once both the flags are turned ON by default then these extra strings can be removed from the below cases
            switch (tooltipName) {
                case metaData.CanceledTip:
                case 'Canceled': return 1;
                    break;
                case metaData.UnmatchedEmptySyncedTip:
                case 'EmptySynced': return 2;
                    break;
                case metaData.DatatypeMismatchTip:
                case 'DataTypeMismatch': return 3;
                    break;
                case metaData.EmptyTip:
                case 'Empty': return 4;
                    break;
                case metaData.UnalignedTip:
                case 'Unaligned': return 5;
                    break;
                case metaData.StartStopMismatchTip:
                case 'StartStopMismatch': return 7;
                    break;
                case metaData.TimeMismatchTip:
                case 'TimeMismatch': return 8;
                    break;
                case metaData.UnitsMismatchTip:
                case 'UnitsMismatch': return 9;
                    break;
                case metaData.UnsupportedTip:
                case 'Unsupported': return 10;
                    break;
                case metaData.MatchedTip:
                case 'WithinTolerance': return 11;
                    break;
                // for out of tolerance signals
                default: return 6;
            }
        }

        function addEventListenersForCmprHeaders () {
            var cmprHeaderCols = document.querySelectorAll('.cmpr-cell-hdr');
            for (var i = 0; i < cmprHeaderCols.length; i++) {
                cmprHeaderCols[i].addEventListener('click', sortColumns);
            }
        }

        function addEventListenersForHighlightRow () {
            var tableBody = document.querySelector('.cmpr-tbl-bdy-content');
            var children = tableBody.children;
            for (var i = 0; i < children.length; i++) {
                children[i].addEventListener('click', rowClickDisplay.bind(children[i], children[i].rowIndex));
            }
        }

        function addSortResizeElements (colHeaders, colIndex, th) {
            var colDiv = document.createElement('div');
            colDiv.setAttribute('class', 'cmprHeaderContent');
            colDiv.innerHTML = colHeaders[colIndex];
            th.appendChild(colDiv);
            var unsortDiv = document.createElement('div');
            unsortDiv.setAttribute('class', 'unsort');
            var arrowUpDiv = document.createElement('div');
            arrowUpDiv.setAttribute('class', 'arrow arrow-up');
            var arrowDownDiv = document.createElement('div');
            arrowDownDiv.setAttribute('class', 'arrow arrow-down');
            unsortDiv.appendChild(arrowUpDiv);
            unsortDiv.appendChild(arrowDownDiv);
            if (colIndex < maxCmprColIndex) {
                var resizeSpan = document.createElement('span');
                resizeSpan.setAttribute('class', 'cmpr-resize-handle');
                th.appendChild(resizeSpan);
            }
            th.appendChild(unsortDiv);
        }

    </script>

    <div id="header" class="header"></div>
    <div id="interactive" class="interactive" draggable="false"></div>
    <div id="printable" class="printable" draggable="false"></div>
<script type="text/javascript">
var isSortingEnabled = true;
    </script><script type="text/javascript">
var isGroupingEnabled = true;
    </script></body>



</html>